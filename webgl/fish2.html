<!DOCTYPE html>
<!--
Draws a fish-eye circle.
-->
<title>fish 2</title>
<canvas width="200" height="200"></canvas>
<script src="3rd-party/twgl-full.js"></script>
<script src="utils.js"></script>
<script>
'use strict'
const gl = document.querySelector('canvas').getContext('webgl2')
gl.clearColor(0.8, 0.9, 1, 1)
gl.clear(gl.COLOR_BUFFER_BIT)
gl.enable(gl.BLEND)
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

const vs = `#version 300 es

in vec3 starPos;
in float n;
uniform vec3 eyePos;
uniform float canvasSize;   // assuming square for now
out vec2 c;
out vec2 io_pos;
out float io_r;

float fish(vec2 v) {
  float len = length(v);
  float denom = v.y + len;
  float FAR_AWAY = 100.0;
  return denom == 0.0 ? FAR_AWAY : v.x / denom;
}

void main() {
  float FAR = 0.001;
  vec3 pos = starPos - eyePos;
  float xz = length(pos.xz);
  float R = 1.0;  // for now
  float k = sqrt(dot(pos, pos) - R * R);
  vec2 a = vec2(xz * k + pos.y * R, pos.y * k - xz * R);
  vec2 b = vec2(xz * k - pos.y * R, pos.y * k + xz * R);
  float af = fish(a);
  float bf = fish(b);
  float r = (af - bf) * 0.5;
  float q = (af + bf) * 0.5;
  float x = xz == 0.0 ? 0.0 : q * pos.x / xz;
  float y = xz == 0.0 ? 0.0 : q * pos.z / xz;
  float scale = canvasSize * 0.5;
  io_r = r * scale;
  r = io_r / scale + 1.0;
  c = vec2(x + 1.0, y + 1.0) * scale;
  gl_Position = vec4(
      n == 0. || n == 3. || n == 5. ? x - r : x + r,
      n == 0. || n == 3. || n == 1. ? y - r : y + r,
      length(pos) * FAR,
      1);
  io_pos = (gl_Position.xy + 1.0) * scale;
}`
const fs = `#version 300 es
precision mediump float;
in vec2 c;
in vec2 io_pos;
in float io_r;
out vec4 finalCol;

float f(float a, float b, float c) {
  return c == a ? 0.0 : (b - a) / (c - a);
}

void main() {
  vec3 fsCol = vec3(1.0, 0.0, 0.0);

  vec2 d = abs(io_pos - c);  // to reduce the cases to one quadrant
  if (d.y > d.x)
    d = d.yx;             // to reduce down to one octant
  vec2 near = d - 0.5;
  vec2 far = d + 0.5;
  float nearSq = dot(near, near);
  float radSq = io_r * io_r;
  if (radSq < nearSq) {
    discard;
    return;
  }
  float farSq = dot(far, far);
  if (radSq > farSq) {
    finalCol = vec4(fsCol, 1);  // completely inside
    return;
  }

  // The remaining cases depend on which corners of the pixel
  // are inside the disc.

  vec2 topLeft = vec2(near.x, far.y);
  float topLeftSq = dot(topLeft, topLeft);
  vec2 botRight = vec2(near.y, far.x);
  float botRightSq = dot(botRight, botRight);
  float k = f(nearSq, radSq, botRightSq);
  if (radSq < topLeftSq) {
    // then the intersection is a triangle, where k is the width and h is the height.
    float h = f(nearSq, radSq, topLeftSq);
    finalCol = vec4(fsCol, pow((h * k * 0.5), 0.4545));
    return;
  }
  float k2 = f(topLeftSq, radSq, farSq);
  if (radSq < botRightSq) {
    // then the intersection is a trapezium.
    finalCol = vec4(fsCol, pow(((k + k2) * 0.5), 0.4545));
    return;
  }
  // else the intersection is the whole pixel minus a triangle.
  float h2 = f(botRightSq, radSq, farSq);
  float opacity = 1.0 - (1.0 - h2) * (1.0 - k2) * 0.5;
  finalCol = vec4(fsCol, pow(opacity, 0.4545));

}`
const pi = twgl.createProgramInfo(gl, [vs, fs])
gl.useProgram(pi.program)
let arrays = {
    starPos: { size: 3, data: [ 2, 2, 0, ], divisor: 1, },
    n:       { size: 1, data: [ 0,1,2,3,4,5, ], },
}
const bi = twgl.createBufferInfoFromArrays(gl, arrays)
const uniforms = { eyePos: [0,0,0], canvasSize: gl.canvas.width, }
twgl.setUniforms(pi, uniforms)
twgl.setBuffersAndAttributes(gl, pi, bi)
twgl.drawBufferInfo(gl, bi, gl.TRIANGLES, 6, 0, 1)
</script>
