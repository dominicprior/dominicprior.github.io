<!DOCTYPE html>
<!--
Draws a fish-eye circle.
-->
<title>fish 2</title>
<canvas width="200" height="200"></canvas>
<script src="3rd-party/twgl-full.js"></script>
<script src="utils.js"></script>
<script>
'use strict'
const gl = document.querySelector('canvas').getContext('webgl2')
gl.clearColor(1.0, 0.8, 0.7, 1.0)   // overall beige background
gl.clear(gl.COLOR_BUFFER_BIT)
gl.enable(gl.BLEND)
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

let yellowVS = `#version 300 es
in vec4 position;
out vec2 pos;
void main() {
  pos = vec2(position);
  gl_Position = position;
}`
let yellowFS = `#version 300 es
precision mediump float;
in vec2 pos;
out vec4 finalCol;
void main() {
  if (dot(pos, pos) > 1.0) {
    discard;
  }
  finalCol = vec4(1, 1, 0, 1);
}`
let yellowPI = twgl.createProgramInfo(gl, [yellowVS, yellowFS])

// ------ Attach the texture and rb to the fb ------

const t = twgl.createTexture(gl, {
  mag: gl.NEAREST,  min: gl.LINEAR,
  src: null,  width: 200,  height: 200,  format: gl.RGBA,
})
const rb = gl.createRenderbuffer()
gl.bindRenderbuffer(gl.RENDERBUFFER, rb)
const fb = gl.createFramebuffer()
gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, t, 0);
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, rb)
gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH24_STENCIL8, 200, 200)

// ------ Create a circular stencil on the rb ------

gl.clearColor(0, 0, 1, 1)  // blue background for the texture
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)
gl.enable(gl.STENCIL_TEST)
gl.stencilFunc(gl.ALWAYS, 1, 0xFF)
gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE)
gl.useProgram(yellowPI.program)
let arrays = { position: { size: 2, data: [ -1,-1, 1,-1, 1,1, -1,1, ], }, }
let bi = twgl.createBufferInfoFromArrays(gl, arrays)
twgl.setBuffersAndAttributes(gl, yellowPI, bi)
twgl.drawBufferInfo(gl, bi, gl.TRIANGLE_FAN)

// ------ Draw the circle on the texture ------

gl.stencilFunc(gl.EQUAL, 1, 0xFF)
gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP)

const fishVS = `#version 300 es

in vec3 starPos;
in float n;
uniform vec3 eyePos;
uniform float canvasSize;   // assuming square for now
out vec2 c;
out vec2 io_pos;
out float io_r;

float fish(vec2 v) {
  float len = length(v);
  float denom = v.y + len;
  float FAR_AWAY = 100.0;
  return denom == 0.0 ? FAR_AWAY : v.x / denom;
}

void main() {
  float FAR = 0.001;
  vec3 pos = starPos - eyePos;
  float xz = length(pos.xz);
  float R = 1.0;  // for now
  float k = sqrt(dot(pos, pos) - R * R);
  vec2 a = vec2(xz * k + pos.y * R, pos.y * k - xz * R);
  vec2 b = vec2(xz * k - pos.y * R, pos.y * k + xz * R);
  float af = fish(a);
  float bf = fish(b);
  float r = (af - bf) * 0.5;
  float q = (af + bf) * 0.5;
  float x = xz == 0.0 ? 0.0 : q * pos.x / xz;
  float y = xz == 0.0 ? 0.0 : q * pos.z / xz;
  float scale = canvasSize * 0.5;
  io_r = r * scale;
  r = io_r / scale + 1.0;
  c = vec2(x + 1.0, y + 1.0) * scale;
  gl_Position = vec4(
      n == 0. || n == 3. || n == 5. ? x - r : x + r,
      n == 0. || n == 3. || n == 1. ? y - r : y + r,
      length(pos) * FAR,
      1);
  io_pos = (gl_Position.xy + 1.0) * scale;
}`
const fishFS = `#version 300 es
precision mediump float;
in vec2 c;
in vec2 io_pos;
in float io_r;
out vec4 finalCol;

float f(float a, float b, float c) {
  return c == a ? 0.0 : (b - a) / (c - a);
}

void main() {
  vec3 fsCol = vec3(1.0, 0.0, 0.0);

  vec2 d = abs(io_pos - c);  // to reduce the cases to one quadrant
  if (d.y > d.x)
    d = d.yx;             // to reduce down to one octant
  vec2 near = d - 0.5;
  vec2 far = d + 0.5;
  float nearSq = dot(near, near);
  float radSq = io_r * io_r;
  if (radSq < nearSq) {
    discard;
    return;
  }
  float farSq = dot(far, far);
  if (radSq > farSq) {
    finalCol = vec4(fsCol, 1);  // completely inside
    return;
  }

  // The remaining cases depend on which corners of the pixel
  // are inside the disc.

  vec2 topLeft = vec2(near.x, far.y);
  float topLeftSq = dot(topLeft, topLeft);
  vec2 botRight = vec2(near.y, far.x);
  float botRightSq = dot(botRight, botRight);
  float k = f(nearSq, radSq, botRightSq);
  if (radSq < topLeftSq) {
    // then the intersection is a triangle, where k is the width and h is the height.
    float h = f(nearSq, radSq, topLeftSq);
    finalCol = vec4(fsCol, h * k * 0.5);
    return;
  }
  float k2 = f(topLeftSq, radSq, farSq);
  if (radSq < botRightSq) {
    // then the intersection is a trapezium.
    finalCol = vec4(fsCol, (k + k2) * 0.5);
    return;
  }
  // else the intersection is the whole pixel minus a triangle.
  float h2 = f(botRightSq, radSq, farSq);
  float opacity = 1.0 - (1.0 - h2) * (1.0 - k2) * 0.5;
  finalCol = vec4(fsCol, opacity);

}`
const pi = twgl.createProgramInfo(gl, [fishVS, fishFS])
gl.useProgram(pi.program)
arrays = {
    starPos: { size: 3, data: [ .9, .7, 0, ], divisor: 1, },
    n:       { size: 1, data: [ 0,1,2,3,4,5, ], },
}
bi = twgl.createBufferInfoFromArrays(gl, arrays)
const uniforms = { eyePos: [0,0,0], canvasSize: gl.canvas.width, }
twgl.setUniforms(pi, uniforms)
twgl.setBuffersAndAttributes(gl, pi, bi)
twgl.drawBufferInfo(gl, bi, gl.TRIANGLES, 6, 0, 1)
gl.bindFramebuffer(gl.FRAMEBUFFER, null)

// ------ Use the texture ------

const textureVS = `#version 300 es
in vec4 position;
in vec2 texcoord;
out vec2 v_texCoord;
void main() {
  v_texCoord = texcoord;
  gl_Position = position;
}`
const textureFS = `#version 300 es
precision mediump float;
in vec2 v_texCoord;
out vec4 finalColour;
uniform sampler2D s;
void main() {
  finalColour = texture(s, v_texCoord);
}`
let texturePI = twgl.createProgramInfo(gl, [textureVS, textureFS])
gl.useProgram(texturePI.program)

arrays = {
    position: { size: 2, data: [ -1,-1, 1,-1, 1,1, -1,1, ], divisor: 0, },
    texcoord: { size: 2, data: [ 0,0, 1,0, 1,1, 0,1, ], divisor: 0, },
}
bi = twgl.createBufferInfoFromArrays(gl, arrays)
twgl.setBuffersAndAttributes(gl, texturePI, bi)
twgl.drawBufferInfo(gl, bi, gl.TRIANGLE_FAN)

</script>
