<!DOCTYPE html>
<!--
  Draw to a render buffer with multi sampling

  I tried using an SRGB8_ALPHA8 internal format for the render buffer
  but everything went blank.  See this:
  https://github.com/KhronosGroup/WebGL/blob/main/conformance-suites/2.0.0/conformance2/rendering/blitframebuffer-test.html#L264
  So maybe it is better do all the graphics in linear space and only
  convert to sRGB space just before sending to the screen.
-->
<title>rb2</title>
<canvas width="200" height="200"></canvas>
<script src="3rd-party/twgl-full.js"></script>
<script>
'use strict'
let colors = {}
const pr = console.log
let canvas = document.querySelector('canvas')
let gl = canvas.getContext('webgl2',
    {antialias: false,
    //premultipliedAlpha: true,  // These two flags didn't
    //alpha: false,              //  help with SRGB8_ALPHA8.
   })

// ------ Draw a blue triangle to the MSAA rb.
// ------ Blit from the rb to the texture.
// ------ Send the texture to the screen.

let vs = `#version 300 es
in vec4 pos;
void main() {
  gl_Position = pos;
}`
let fs = `#version 300 es
precision mediump float;
out vec4 finalCol;
void main() {
  finalCol = vec4(0, 0, 1, 1);    // blue triangle
}`
let pi = twgl.createProgramInfo(gl, [vs, fs])
gl.useProgram(pi.program)
let arrays = {
    pos: { size: 2, data: [ -0.2, -0.4,    0, 0.9,   0.9, -0.6,], },
}
let bi = twgl.createBufferInfoFromArrays(gl, arrays)
twgl.setBuffersAndAttributes(gl, pi, bi)

let fb_rb = gl.createFramebuffer()
const rb = gl.createRenderbuffer()
gl.bindRenderbuffer(gl.RENDERBUFFER, rb)

gl.renderbufferStorageMultisample(gl.RENDERBUFFER, gl.getParameter(gl.MAX_SAMPLES), gl.RGBA8, 200, 200)  // rb <=== multi sample

gl.bindFramebuffer(gl.FRAMEBUFFER, fb_rb)
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, rb)   // fb_rb <---> rb

twgl.drawBufferInfo(gl, bi)  // draw to the rb

let fb_texture = gl.createFramebuffer()
gl.bindFramebuffer(gl.FRAMEBUFFER, fb_texture)
let texture = twgl.createTexture(gl, {
  mag: gl.NEAREST,
  min: gl.LINEAR,
  src: null,
  width: 200,  height: 200,
})
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0)  // fb_texture <---> texture

gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb_rb)
gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb_texture)
gl.clearBufferfv(gl.COLOR, 0, [1.0, 1.0, 1.0, 1.0])
gl.blitFramebuffer(0, 0, 200, 200,
                        0, 0, 200, 200,
                        gl.COLOR_BUFFER_BIT, gl.LINEAR)  // rb --> texture

gl.bindFramebuffer(gl.FRAMEBUFFER, null);

// ------ send the texture to the screen with gamma correction ------

vs = `#version 300 es
in vec4 position;
in vec2 texcoord;
out vec2 v_texCoord;
void main() {
  v_texCoord = texcoord;
  gl_Position = position;
}`;
fs = `#version 300 es
precision mediump float;
in vec2 v_texCoord;
out vec4 finalColour;
uniform sampler2D s;
float k = 0.4545;
void main() {
  vec4 t = texture(s, v_texCoord);
  finalColour = pow(t, vec4(k,k,k,1));
}`;
gl.clearColor(0, 1, 0, 1.0)
gl.clear(gl.COLOR_BUFFER_BIT)

pi = twgl.createProgramInfo(gl, [vs, fs])
gl.useProgram(pi.program)

arrays = {
    position: { size: 2, data: new Float32Array([ -1,-1, 1,-1, 1,1, ]), },
    texcoord: { size: 2, data: [ 0,0, 1,0, 1,1, ], },
}
bi = twgl.createBufferInfoFromArrays(gl, arrays)
twgl.setBuffersAndAttributes(gl, pi, bi)
twgl.drawBufferInfo(gl, bi, gl.TRIANGLES)

hist()

function hist() {
  gl.flush()
  colors = {}
  let pixels = new Uint8Array(4 * canvas.width * canvas.height)
  gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
  let para = document.createElement('p');
  document.body.appendChild(para)
  for (let i=0; i < pixels.length; i +=4) {
    let color = ''
    for (let j=0; j < 3; j++) {
      color += pixels[i+j] + ', '
    }
    if (colors[color]) {
      colors[color]++
    }
    else {
      colors[color] = 1
    }
  }
  for (let c in colors) {
    let msg = c + ' --- ' + colors[c]
    pr(msg)
    para.insertAdjacentHTML('beforeend', msg + '<br>')
  }
}

</script>
