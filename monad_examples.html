
<!DOCTYPE html><html><head><script type="text/javascript">(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(d){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})()
</script>
<script type="text/javascript">var KX_timer = new window.jstiming.Timer(); KX_timer.name = 'published';</script><title>Monad Examples</title><link rel="shortcut icon" href="https://ssl.gstatic.com/docs/documents/images/kix-favicon6.ico"><style type="text/css">
      body {
        font-family: arial, sans, sans-serif;
        margin: 0;
      }

      iframe {
        border: 0;
        frameborder: 0;
        height: 100%;
        width: 100%;
      }

      #header, #footer {
        background: #f0f0f0;
        padding: 10px 10px;
      }

      #header {
        border-bottom: 1px #ccc solid;
      }

      #footer {
        border-top: 1px #ccc solid;
        border-bottom: 1px #ccc solid;
        font-size: 13;
      }

      #contents {
        margin: 6px;
      }

      .dash {
        padding: 0 6px;
      }
    </style></head><body><div id="header">Monad Examples</div><div id="contents"><style type="text/css">.lst-kix_lms5u5un3oa5-4>li:before{content:"\0025cb  "}.lst-kix_lms5u5un3oa5-3>li:before{content:"\0025cf  "}.lst-kix_lms5u5un3oa5-5>li:before{content:"\0025a0  "}.lst-kix_lms5u5un3oa5-2>li:before{content:"\0025a0  "}.lst-kix_lms5u5un3oa5-6>li:before{content:"\0025cf  "}.lst-kix_lms5u5un3oa5-0>li:before{content:"\0025cf  "}ul.lst-kix_lms5u5un3oa5-1{list-style-type:none}ul.lst-kix_lms5u5un3oa5-2{list-style-type:none}.lst-kix_lms5u5un3oa5-8>li:before{content:"\0025a0  "}.lst-kix_lms5u5un3oa5-1>li:before{content:"\0025cb  "}ul.lst-kix_lms5u5un3oa5-3{list-style-type:none}.lst-kix_lms5u5un3oa5-7>li:before{content:"\0025cb  "}ul.lst-kix_lms5u5un3oa5-4{list-style-type:none}ul.lst-kix_lms5u5un3oa5-0{list-style-type:none}ul.lst-kix_lms5u5un3oa5-5{list-style-type:none}ul.lst-kix_lms5u5un3oa5-6{list-style-type:none}ul.lst-kix_lms5u5un3oa5-7{list-style-type:none}ul.lst-kix_lms5u5un3oa5-8{list-style-type:none}ol{margin:0;padding:0}.c1{margin-left:36pt;orphans:2;widows:2;direction:ltr;height:11pt}.c3{orphans:2;widows:2;direction:ltr}.c4{background-color:#f9f9f9;font-family:"Verdana";color:#252525}.c17{padding:0;margin:0}.c22{padding-top:12pt;padding-bottom:2pt}.c12{color:inherit;text-decoration:inherit}.c19{font-size:21pt;font-family:"Trebuchet MS"}.c10{color:#1155cc;text-decoration:underline}.c20{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c9{color:#252525}.c23{text-align:center}.c2{background-color:#fff2cc}.c8{background-color:#ffffff}.c18{padding-left:0pt}.c6{color:#0000ff}.c11{color:#ff0000}.c5{height:11pt}.c16{font-style:italic}.c0{font-family:"Courier New"}.c21{font-size:14pt}.c13{font-weight:bold}.c7{page-break-after:avoid}.c15{color:#00a000}.c14{margin-left:36pt}.title{padding-top:0pt;color:#000000;font-size:21pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:13pt;padding-bottom:10pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:10pt;color:#0000ff;font-size:18pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:10pt;color:#0000ff;font-weight:bold;font-size:14pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:8pt;color:#666666;font-weight:bold;font-size:12pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:8pt;color:#666666;text-decoration:underline;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:8pt;color:#666666;font-size:11pt;padding-bottom:0pt;font-family:"Trebuchet MS";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style><p class="c3 c23"><span class="c6 c19">Monads</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Here are some simple examples that complement the elegant theory in Martin Oldfield’s </span><span class="c10"><a class="c12" href="https://www.google.com/url?q=http://www.mjoldfield.com/atelier/2014/01/monads-algebra.html&amp;sa=D&amp;usg=AFQjCNGSMBFszG2yRhM-YyJKG2zTk_Kcjw">monad algebra</a></span><span>.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>The simplest non-trivial monad is the Maybe monad.</span></p><h1 class="c3 c7"><a name="h.3fuj02vbumjd"></a><span>Maybe monad</span></h1><p class="c3"><span>The bind operator for the Maybe monad is like this.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">Nothing </span><span class="c2 c11 c0">&gt;&gt;=</span><span class="c2 c0"> </span><span class="c2 c6 c0">_</span><span class="c2 c0"> </span><span class="c2 c11 c0">=</span><span class="c2 c0"> Nothing</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">Just x </span><span class="c2 c11 c0">&gt;&gt;=</span><span class="c2 c0"> f </span><span class="c2 c11 c0">=</span><span class="c2 c0"> f x</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Notice how the right-hand side is simply </span><span class="c2 c0">f x</span><span>.  There is no need for another </span><span class="c2 c0">Just</span><span>, because the type for </span><span class="c2 c0">&gt;&gt;=</span><span> is like this (which we can see by typing </span><span class="c2 c0">&gt;&gt;=</span><span> into Hoogle):</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c11 c0">  </span><span class="c2 c11 c0">(</span><span class="c2 c0">&gt;&gt;=</span><span class="c2 c11 c0">)</span><span class="c2 c0"> </span><span class="c2 c11 c0">::</span><span class="c2 c0"> m a </span><span class="c2 c11 c0">-&gt;</span><span class="c2 c0"> </span><span class="c2 c11 c0">(</span><span class="c2 c0">a </span><span class="c2 c11 c0">-&gt;</span><span class="c2 c0"> m b</span><span class="c2 c11 c0">)</span><span class="c2 c0"> </span><span class="c2 c11 c0">-&gt;</span><span class="c2 c0"> m b</span></p><p class="c3 c5"><span class="c2 c0"></span></p><p class="c3"><span>Specifically, the overall return type of </span><span class="c2 c0">&gt;&gt;=</span><span> is the same as that of the </span><span class="c2 c0">a -&gt; m b</span><span> function.</span></p><p class="c3"><span>The role of the bind operator is to let the </span><span class="c2 c0">f</span><span> consume an unboxed argument and emit a boxed argument.</span></p><h2 class="c3 c7"><a name="h.k40xdod15bn"></a><span>Example</span></h2><p class="c3"><span>We need a function that can fail:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half </span><span class="c2 c11 c0">::</span><span class="c2 c0"> Int </span><span class="c2 c11 c0">-&gt;</span><span class="c0 c2"> Maybe Int</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half x </span><span class="c2 c11 c0">=</span><span class="c2 c0"> </span><span class="c2 c6 c0 c13">if</span><span class="c2 c0 c13"> </span><span class="c2 c0">even x </span><span class="c2 c6 c0 c13">then</span><span class="c2 c0 c13"> </span><span class="c2 c0">Just </span><span class="c2 c11 c0">$</span><span class="c2 c0"> x `div` 2 </span><span class="c2 c6 c0 c13">else</span><span class="c2 c0"> Nothing</span></p><p class="c3 c5"><span class="c2 c0"></span></p><p class="c3"><span>The </span><span class="c2 c0">half</span><span> function is convenient for chaining because the </span><span class="c2 c0">a</span><span> and </span><span class="c2 c0">b</span><span> types are the same.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half 6</span><span class="c0">  ⇒  Just 3</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half 7</span><span class="c0">  ⇒  Nothing</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half </span><span class="c2 c11 c0">$</span><span class="c2 c0"> half 4</span><span class="c0">  ⇒  </span><span class="c11 c0">Compile error</span></p><p class="c3"><span class="c11 c0">  </span><span class="c2 c0">return 4 </span><span class="c2 c11 c0">&gt;&gt;=</span><span class="c2 c0"> half </span><span class="c2 c11 c0">&gt;&gt;=</span><span class="c2 c0"> half</span><span class="c0">  ⇒  Just 1</span></p><p class="c3"><span class="c11 c0">  </span><span class="c2 c0">half 4 </span><span class="c2 c11 c0">&gt;&gt;=</span><span class="c2 c0"> half</span><span class="c0">  ⇒  Just 1</span></p><p class="c3"><span class="c11 c0">  </span><span class="c2 c0">half </span><span class="c2 c11 c0">=&lt;&lt;</span><span class="c2 c0"> half 4</span><span class="c0">  ⇒  Just 1</span></p><p class="c3 c5"><span class="c11 c0"></span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Or more pleasingly:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half </span><span class="c2 c11 c0">&gt;=&gt;</span><span class="c2 c0"> half </span><span class="c2 c11 c0">$</span><span class="c2 c0"> 4</span><span class="c0">  ⇒  Just 1</span></p><p class="c3 c5"><span></span></p><h1 class="c3 c7"><a name="h.vk3p1rhsq3sx"></a><span>Monad transformers</span></h1><p class="c3"><span>The second simplest Monad is the Writer Monad.  Let&#39;s extend our </span><span class="c2 c0">half</span><span> function to include some logging.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half </span><span class="c2 c11 c0">::</span><span class="c2 c0"> Int </span><span class="c2 c11 c0">-&gt;</span><span class="c2 c0"> WriterT String Maybe Int</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half x </span><span class="c2 c11 c0">=</span><span class="c2 c0"> </span><span class="c2 c6 c0 c13">do</span></p><p class="c3"><span class="c0">    </span><span class="c2 c0">tell &quot;hello&quot;</span></p><p class="c3"><span class="c0">    </span><span class="c2 c0">lift </span><span class="c2 c11 c0">$</span><span class="c2 c0"> </span><span class="c2 c6 c0 c13">if</span><span class="c2 c0"> even x </span><span class="c2 c6 c0 c13">then </span><span class="c2 c0">Just </span><span class="c2 c11 c0">$</span><span class="c2 c0"> x `div` 2 </span><span class="c2 c6 c0 c13">else </span><span class="c2 c0">Nothing</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Then we can say this:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">runWriterT </span><span class="c2 c11 c0">$ </span><span class="c2 c0">half </span><span class="c2 c11 c0">&gt;=&gt;</span><span class="c2 c0"> half </span><span class="c2 c11 c0">$</span><span class="c2 c0"> 4</span><span class="c0">  ⇒  Just (1,&quot;hellohello&quot;)</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Here it is the other way round.  (It took hours to get this to compile!  Even now, I am not sure what the </span><span class="c2 c0">return</span><span> stands for!).</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half </span><span class="c2 c11 c0">::</span><span class="c2 c0"> Int </span><span class="c2 c11 c0">-&gt;</span><span class="c2 c0"> MaybeT </span><span class="c2 c11 c0">(</span><span class="c2 c0">Writer String</span><span class="c2 c11 c0">)</span><span class="c2 c0"> Int</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">half x </span><span class="c2 c11 c0">=</span><span class="c2 c0"> </span><span class="c2 c6 c0 c13">do</span></p><p class="c3"><span class="c0">    </span><span class="c2 c0">lift </span><span class="c2 c11 c0">$</span><span class="c2 c0"> tell &quot;hello&quot;</span></p><p class="c3"><span class="c0">    </span><span class="c2 c0">MaybeT </span><span class="c2 c11 c0">$</span><span class="c2 c0"> return </span><span class="c2 c11 c0">$</span><span class="c2 c0"> </span><span class="c2 c6 c0 c13">if </span><span class="c2 c0">even x </span><span class="c2 c6 c0 c13">then </span><span class="c2 c0">Just </span><span class="c2 c11 c0">$</span><span class="c2 c0"> x `div` 2 </span><span class="c2 c6 c0 c13">else </span><span class="c2 c0">Nothing</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>This time we get a different answer.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">runWriter </span><span class="c2 c11 c0">$</span><span class="c2 c0"> runMaybeT </span><span class="c2 c11 c0">$</span><span class="c2 c0"> half </span><span class="c2 c11 c0">&gt;=&gt;</span><span class="c2 c0"> half </span><span class="c2 c11 c0">$</span><span class="c2 c0"> 4</span><span class="c0">  </span><span class="c0">⇒</span><span class="c0">  (Just 1,&quot;hellohello&quot;)</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Notice that the answer is upside-down!  It looks like a writer of maybes, although the monad transformers define it as a MaybeT of writers.</span></p><h1 class="c3 c7"><a name="h.fec9t3dk8zs"></a><span>Making code monadic</span></h1><p class="c3"><span>Here is some simple non-monadic code.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">f&#39; </span><span class="c2 c11 c0">::</span><span class="c2 c0"> Int </span><span class="c2 c11 c0">-&gt;</span><span class="c2 c0"> Int</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">f&#39; 0 </span><span class="c2 c11 c0">=</span><span class="c2 c0"> 1</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">f&#39; n </span><span class="c2 c11 c0">=</span><span class="c2 c0"> n </span><span class="c2 c11 c0">*</span><span class="c2 c0"> f&#39; </span><span class="c2 c11 c0">(</span><span class="c2 c0">n </span><span class="c2 c11 c0">-</span><span class="c2 c0"> 1</span><span class="c2 c11 c0">)</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>And here it is turned into monadic code.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">f </span><span class="c2 c11 c0">::</span><span class="c2 c0"> Int </span><span class="c2 c11 c0">-&gt;</span><span class="c2 c0"> Writer </span><span class="c2 c11 c0">[</span><span class="c2 c0">String</span><span class="c2 c11 c0">]</span><span class="c2 c0"> Int</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">f 0 </span><span class="c2 c11 c0">=</span><span class="c2 c0"> return 1</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">f n </span><span class="c2 c11 c0">=</span><span class="c2 c0"> do</span></p><p class="c3"><span class="c0">    </span><span class="c2 c0">k </span><span class="c2 c11 c0">&lt;-</span><span class="c2 c0"> f </span><span class="c2 c11 c0">$</span><span class="c2 c0"> n-1</span></p><p class="c3"><span class="c0">    </span><span class="c2 c0">return </span><span class="c2 c11 c0">$</span><span class="c2 c0"> n </span><span class="c2 c11 c0">*</span><span class="c2 c0"> k</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>The steps were:</span></p><p class="c3 c5"><span></span></p><ul class="c17 lst-kix_lms5u5un3oa5-0 start"><li class="c3 c18 c14"><span>Change the return type from a plain old </span><span class="c2 c0">Int</span><span> into an </span><span class="c2 c0">Int</span><span> in the </span><span class="c2 c0">Writer </span><span class="c2 c11 c0">[</span><span class="c2 c0">String</span><span class="c2 c11 c0">]</span><span> monad.</span></li><li class="c3 c18 c14"><span>Make sure the answers are promoted with </span><span class="c2 c0">return</span><span>.</span></li><li class="c3 c14 c18"><span>Call the function via the </span><span class="c2 c11">&lt;-</span><span> syntax, so the </span><span class="c2 c0">k</span><span> is non-monadic.</span></li></ul><p class="c3 c5"><span></span></p><p class="c3"><span>Once the code is monadic, we can add calls to </span><span class="c2 c0">tell</span><span> where we like.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Monadic code can call non-monadic code, e.g. the </span><span class="c2 c0">n </span><span class="c2 c11 c0">*</span><span class="c2 c0"> k</span><span> in this case.  We are used to this from the IO monad.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>However, unlike in the IO monad, we can have non-monadic code call monadic code.  For example:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">g </span><span class="c2 c11 c0">::</span><span class="c2 c0"> Int </span><span class="c2 c11 c0">-&gt;</span><span class="c2 c0"> Int</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">g n </span><span class="c2 c11 c0">=</span><span class="c2 c0"> fst </span><span class="c2 c11 c0">$</span><span class="c2 c0"> runWriter </span><span class="c2 c11 c0">$</span><span class="c2 c0"> f n</span></p><h1 class="c3 c7"><a name="h.738pzub62b0r"></a><span>A simpler monad example</span></h1><p class="c3"><span class="c0">  </span><span class="c2 c0">w </span><span class="c2 c11 c0">::</span><span class="c2 c0"> Writer String Int</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">w </span><span class="c2 c11 c0">=</span><span class="c2 c0"> tell &quot;hi&quot; </span><span class="c2 c11 c0">&gt;&gt;</span><span class="c2 c0"> return 3</span></p><p class="c3"><span>Here’s the same thing:</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">w </span><span class="c2 c11 c0">::</span><span class="c2 c0"> WriterT String Identity Int</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">w </span><span class="c2 c11 c0">=</span><span class="c2 c0"> WriterT </span><span class="c2 c11 c0">$</span><span class="c2 c0"> Identity (3, &quot;hi&quot;)</span></p><p class="c3"><span>We can run them like in either of these two ways:</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">runWriter w</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">runIdentity </span><span class="c2 c11 c0">$</span><span class="c2 c0"> runWriterT w</span></p><p class="c3"><span>To compile them, it seems to be enough to use either of these:</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">import Control.Monad.Writer</span></p><p class="c3"><span class="c0">  </span><span class="c2 c0">import Control.Monad.Trans.Writer</span></p><h1 class="c3 c7"><a name="h.664wzfuw2gux"></a><span>Readers and Writers</span></h1><p class="c3"><span>Here are readers and writers together.  Due to some deep magic, all the lifts are optional.  However, I have kept the lifts for emphasis.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  run_rw = runWriter $ runReaderT rw &quot;foo&quot;</span></p><p class="c3"><span class="c0">  rw :: ReaderT String (Writer String) Int</span></p><p class="c3"><span class="c0">  rw = do</span></p><p class="c3"><span class="c0">    s &lt;- ask</span></p><p class="c3"><span class="c0">    lift $ tell &quot;hi&quot;</span></p><p class="c3"><span class="c0">    lift $ return $ length s</span></p><p class="c3"><span class="c0">  </span></p><p class="c3"><span class="c0">  run_wr = runReader (runWriterT wr) &quot;foo&quot;</span></p><p class="c3"><span class="c0">  wr :: WriterT String (Reader String) Int</span></p><p class="c3"><span class="c0">  wr = do</span></p><p class="c3"><span class="c0">    s &lt;- lift $ ask</span></p><p class="c3"><span class="c0">    tell &quot;hi&quot;</span></p><p class="c3"><span class="c0">    lift $ return $ length s</span></p><h1 class="c3 c7"><a name="h.c8d24hkmsqp9"></a><span>Writers and writers</span></h1><p class="c3"><span>I’m not sure why anyone would want two layers of writers, but here goes anyway.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  run_ww = runWriter $ runWriterT ww</span></p><p class="c3"><span class="c0">  ww :: WriterT String (Writer String) Int</span></p><p class="c3"><span class="c0">  ww = do</span></p><p class="c3"><span class="c0">    lift $ tell &quot;lifted&quot;</span></p><p class="c3"><span class="c0">    tell &quot;hi&quot;</span></p><p class="c3"><span class="c0">    lift $ return $ 3</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>However, it does allow us to see the inside-out nature of monad transformers.  From the source code </span><span class="c10"><a class="c12" href="https://www.google.com/url?q=http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-Writer-Lazy.html&amp;sa=D&amp;usg=AFQjCNGmbfFKV6OMYrllRxf4iW-krZW35Q">here</a></span><span>, we see this:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c6 c0">  newtype</span><span class="c0"> WriterT w m a </span><span class="c11 c0">=</span><span class="c0"> WriterT </span><span class="c11 c0">{</span><span class="c0"> runWriterT </span><span class="c11 c0">::</span><span class="c0"> m </span><span class="c11 c0">(</span><span class="c0">a</span><span class="c11 c0">,</span><span class="c0"> w</span><span class="c11 c0">)</span><span class="c0"> </span><span class="c11 c0">}</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>It shows us that the the writer monad, the “(a, w)”, is inside the guest monad, “m”.  We can see from the “readers and writers” section that it is the guest that uses lift.  In this writer-writer example, the guest writer is saying “lifted” and the host writer is saying “hi”.  Then, because the host monad tucks itself inside, we shouldn’t be surprised to see the “hi” on the inside and the “lifted” on the outside.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">  *Main&gt; run_ww</span></p><p class="c3"><span class="c0">  ((3,&quot;hi&quot;),&quot;lifted&quot;)</span></p><h1 class="c3 c7"><a name="h.994d9dm388xp"></a><span>Monadic functions</span></h1><p class="c3"><span>liftM  ≡  fmap</span></p><p class="c3"><span>ap ≡ (&lt;*&gt;)</span></p><p class="c3"><span>liftM2 ≡ liftA2 ≡ …&lt;$&gt;...&lt;*&gt;...</span></p><h1 class="c3 c7"><a name="h.hi8iqveoet3g"></a><span>Parsers</span></h1><p class="c3"><span>Here’s a simple parser for reading a number..</span></p><p class="c3 c5"><span></span></p><p class="c3 c14"><span class="c0">import Text.Parsec</span></p><p class="c3 c14"><span class="c0">import Text.Parsec.String</span></p><p class="c3 c14"><span class="c0">import Control.Applicative hiding ((&lt;|&gt;))</span></p><p class="c1"><span class="c0"></span></p><p class="c3 c14"><span class="c0">num :: Parser Int</span></p><p class="c3 c14"><span class="c0">num = read &lt;$&gt; many1 digit</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>And here’s a parser that allows numbers to be chained together with minus signs.</span></p><p class="c3 c5"><span></span></p><p class="c3 c14"><span class="c0">t :: Parser Int</span></p><p class="c3 c14"><span class="c0">t = chainl1 num (char &#39;-&#39; &gt;&gt; return (-))</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>We can run the parser like this, to get the answer, 4.</span></p><p class="c3 c5"><span></span></p><p class="c3 c14"><span class="c0">parse t &quot;&quot; &quot;8-2-2&quot;</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Note how the the minus signs are left-associative.  In the original </span><span class="c10"><a class="c12" href="https://www.google.com/url?q=http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.pdf&amp;sa=D&amp;usg=AFQjCNEIoiXTb7uxGRjlFjRrXeotAwB5yg">Parsec paper</a></span><span> they say that left-associative grammars send combinator parsers into an infinite loop, but, luckily, chainl1 rewrites the grammar.  Note how the second argument to chainl1 is higher-order.</span></p><p class="c3 c5"><span></span></p><h1 class="c3 c7"><a name="h.ozawozvnz67h"></a><span>Forall</span></h1><p class="c3 c14"><span class="c0">{-# LANGUAGE ExistentialQuantification #-}</span></p><p class="c1"><span class="c0"></span></p><p class="c3 c14"><span class="c0">data Foo = forall a. Show a =&gt; Foo a</span></p><p class="c1"><span class="c0"></span></p><p class="c3 c14"><span class="c0">a :: [Foo]</span></p><p class="c3 c14"><span class="c0">a = [Foo True, Foo &#39;q&#39;]  </span><span class="c0 c13 c15">-- weird mixture</span></p><p class="c1"><span class="c0"></span></p><p class="c3 c14"><span class="c0">g :: Foo -&gt; String</span></p><p class="c3 c14"><span class="c0">g (Foo x) = show x</span></p><p class="c1"><span class="c0"></span></p><p class="c3 c14"><span class="c0">f :: [String]</span></p><p class="c3 c14"><span class="c0">f = map g a</span></p><h1 class="c3 c7"><a name="h.on7ws6lar8cj"></a><span>Syntax</span></h1><p class="c3"><span class="c0">foo u v = stuff</span></p><p class="c3"><span class="c0">  where a = b</span></p><p class="c3"><span class="c0">        c = d</span></p><p class="c3 c5"><span class="c0"></span></p><p class="c3"><span class="c0">let a = b</span></p><p class="c3"><span class="c0">    c = d</span></p><p class="c3"><span class="c0">in stuff</span></p><p class="c3 c5"><span class="c0"></span></p><p class="c3"><span class="c0">case expression of pattern -&gt; result  </span></p><p class="c3"><span class="c0">                   pattern -&gt; result  </span></p><p class="c3"><span class="c0">                   pattern -&gt; result</span></p><p class="c3 c5"><span class="c0"></span></p><p class="c3"><span class="c0">case expr of</span></p><p class="c3"><span class="c0">  Left a  -&gt; stuff</span></p><p class="c3"><span class="c0">  Right b -&gt; stuff</span></p><p class="c3 c5"><span class="c0"></span></p><p class="c3"><span class="c0">\x -&gt; x^2</span></p><h1 class="c3 c7"><a name="h.xucxjuwma7jx"></a><span>Random notes</span></h1><p class="c3"><span>ByteString is for raw sequences of bytes.</span></p><p class="c3"><span>Text is for unicode text.</span></p><p class="c3"><span>foldM is the monadic equivalent of foldl.</span></p><p class="c3"><span>mapM            </span><span class="c11">::</span><span> Monad m </span><span class="c11">=&gt;</span><span> </span><span class="c11">(</span><span>a </span><span class="c11">-&gt;</span><span> m b</span><span class="c11">)</span><span> </span><span class="c11">-&gt;</span><span> </span><span class="c11">[</span><span>a</span><span class="c11">]</span><span> </span><span class="c11">-&gt;</span><span> m </span><span class="c11">[</span><span>b</span><span class="c11">]</span></p><p class="c3"><span>sequence       </span><span class="c11">::</span><span> Monad m </span><span class="c11">=&gt;</span><span> </span><span class="c11">[</span><span>m a</span><span class="c11">]</span><span> </span><span class="c11">-&gt;</span><span> m </span><span class="c11">[</span><span>a</span><span class="c11">]</span></p><p class="c3"><span>f $! x = let !v = x in f v</span></p><h2 class="c3 c7"><a name="h.yt0bq87ggfa"></a><span>WHNF</span></h2><p class="c3"><span>NF means completely evaluated.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c8">An expression in WHNF has been evaluated to the outermost data constructor or lambda abstraction (the </span><span class="c8 c16">head</span><span class="c8">).  E.g. (1+1, 2+2).</span></p><p class="c3 c5"><span></span></p><h1 class="c3 c7"><a name="h.8ddq7qmbaukq"></a><span>Repl</span></h1><p class="c3"><span>import System.IO</span></p><p class="c3"><span>type Env = [(String, String)]</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>main :: IO ()</span></p><p class="c3"><span>main = loop [] &gt;&gt; return ()</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>loop :: Env -&gt; IO Env</span></p><p class="c3"><span>loop env = do</span></p><p class="c3"><span>  str &lt;- putStr &quot;&gt;&gt;&gt; &quot; &gt;&gt; hFlush stdout &gt;&gt; getLine</span></p><p class="c3"><span>  if (str == &quot;quit&quot;)</span></p><p class="c3"><span>  then return []</span></p><p class="c3"><span>  else do</span></p><p class="c3"><span>    let (ans, env&#39;) = evalString env str</span></p><p class="c3"><span>    putStrLn ans</span></p><p class="c3"><span>    loop env&#39;</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>evalString :: Env -&gt; String -&gt; (String, Env)</span></p><p class="c3"><span>evalString env (c : &#39;=&#39; : str) = (&quot;ok&quot;, ([c], str) : env)</span></p><p class="c3"><span>evalString env [c] = case lookup [c] env of</span></p><p class="c3"><span>    Nothing  -&gt; (&quot;unknown&quot;, env)</span></p><p class="c3"><span>    Just str -&gt; (str, env)</span></p><p class="c3"><span>evalString env _ = (&quot;eh?&quot;, env)</span></p><h1 class="c3 c7"><a name="h.60ih8drdlnle"></a><span>Repl with State monad</span></h1><p class="c3"><span>import System.IO</span></p><p class="c3"><span>import Control.Monad.State</span></p><p class="c3"><span>type Env = [(String, String)]</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>main :: IO ()</span></p><p class="c3"><span>main = loop [] &gt;&gt; return ()</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>loop :: Env -&gt; IO Env</span></p><p class="c3"><span>loop env = do</span></p><p class="c3"><span>  str &lt;- putStr &quot;&gt;&gt;&gt; &quot; &gt;&gt; hFlush stdout &gt;&gt; getLine</span></p><p class="c3"><span>  if (str == &quot;quit&quot;)</span></p><p class="c3"><span>  then return []</span></p><p class="c3"><span>  else do</span></p><p class="c3"><span>    let (ans, env&#39;) = runState (evalString str) env</span></p><p class="c3"><span>    putStrLn ans</span></p><p class="c3"><span>    loop env&#39;</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>evalString :: String -&gt; State Env String</span></p><p class="c3"><span>evalString (c : &#39;=&#39; : str) = modify (([c], str) :) &gt;&gt; return &quot;ok&quot;</span></p><p class="c3"><span>evalString [c] = do</span></p><p class="c3"><span>  env &lt;- get</span></p><p class="c3"><span>  case lookup [c] env of</span></p><p class="c3"><span>    Nothing  -&gt; return &quot;unknown&quot;</span></p><p class="c3"><span>    Just str -&gt; return str</span></p><p class="c3"><span>evalString _ = return &quot;eh?&quot;</span></p><h1 class="c3 c7"><a name="h.tihrrmnxhke9"></a><span>Repl with State monad and Haskeline</span></h1><p class="c3"><span>import System.Console.Haskeline</span></p><p class="c3"><span>import System.IO</span></p><p class="c3"><span>import Control.Monad.State</span></p><p class="c3"><span>import Control.Monad.Identity</span></p><p class="c3"><span>type Env = [(String, String)]</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>main :: IO ()</span></p><p class="c3"><span>main = runInputT defaultSettings (runStateT loop []) &gt;&gt; return ()</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>-- mapStateT :: (m (a, w) -&gt; n (b, w&#39;)) -&gt; StateT w m a -&gt; StateT w&#39; n b</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>-- With our mapper function we need to turn evalString &quot;foo&quot;</span></p><p class="c3"><span>-- from StateT Env Identity    String</span></p><p class="c3"><span>-- to   StateT Env (InputT IO) String</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>-- i.e. in the above, w and w&#39; are Env.</span></p><p class="c3"><span>--   m is Identity and n is InputT IO</span></p><p class="c3"><span>--   a and b are String.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>mapper :: Identity (String, Env) -&gt; (InputT IO) (String, Env)</span></p><p class="c3"><span>mapper (Identity (str, env)) = return (str, env)</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>loop :: StateT Env (InputT IO) ()</span></p><p class="c3"><span>loop = do</span></p><p class="c3"><span>  maybeStr &lt;- lift $ getInputLine &quot;&gt;&gt;&gt; &quot;</span></p><p class="c3"><span>  case maybeStr of</span></p><p class="c3"><span>    Nothing -&gt; return ()</span></p><p class="c3"><span>    Just &quot;quit&quot; -&gt; return ()</span></p><p class="c3"><span>    Just str -&gt; do</span></p><p class="c3"><span>      ans &lt;- mapStateT mapper (evalString str)</span></p><p class="c3"><span>      lift $ outputStrLn ans</span></p><p class="c3"><span>      loop</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>evalString :: String -&gt; State Env String</span></p><p class="c3"><span>evalString (c : &#39;=&#39; : str) = modify (([c], str) :) &gt;&gt; return &quot;ok&quot;</span></p><p class="c3"><span>evalString [c] = do</span></p><p class="c3"><span>  env &lt;- get</span></p><p class="c3"><span>  case lookup [c] env of</span></p><p class="c3"><span>    Nothing  -&gt; return &quot;unknown&quot;</span></p><p class="c3"><span>    Just str -&gt; return str</span></p><p class="c3"><span>evalString _ = return &quot;eh?&quot;</span></p><h1 class="c3 c7"><a name="h.4na7s82vrzfv"></a><span>liftA2 trick</span></h1><p class="c3"><span class="c0">av = liftA2 (/) sum length</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>We can see why this works by analogy with liftA:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">liftA sqrt f x = sqrt (f x)</span></p><p class="c3"><span class="c0">liftA2 op f g x = op (f x) (g x)</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>More tricks:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>join (*)</span></p><p class="c3"><span>(sqrt .) . (+)</span></p><p class="c3"><span>curry $ sqrt . uncurry (+)</span></p><h1 class="c3 c7"><a name="h.8ywkvzwv8j9"></a><span>Installing on a fresh Linux Mint 17</span></h1><p class="c3"><span>The Mint community suggestion on Haskell Platform didn’t seem to work at all.  So I used the generic linux binary instead.  Here’s the final report from running sudo /usr/local/haskell/ghc-7.8.3-x86_64/bin/activate-hs </span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Haskell set to:</span></p><p class="c3"><span>    GHC         /usr/local/haskell/ghc-7.8.3-x86_64</span></p><p class="c3"><span>    Haddocks    file:///usr/local/haskell/ghc-7.8.3-x86_64/doc/frames.html</span></p><p class="c3"><span>    Other doc   file:///usr/local/haskell/ghc-7.8.3-x86_64/share/doc/ghc/html/index.html</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Symlinks for command line tools (ghc, cabal, etc..) added to:</span></p><p class="c3"><span>    /usr/local/bin</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>When I typed ghci, I got this: libgmp.so: cannot open shared object file: No such file or directory</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>I typed this: apt install libgmp-dev</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Then ghci worked!  But cabal failed, until I applied this fix.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c10"><a class="c12" href="https://www.google.com/url?q=http://stackoverflow.com/questions/24502896/error-executing-cabal-install-cabal-install-usr-bin-ld-cannot-find-lz&amp;sa=D&amp;usg=AFQjCNERtwFJWCIr7dt4adVv5ABozmKFrA">http://stackoverflow.com/questions/24502896/error-executing-cabal-install-cabal-install-usr-bin-ld-cannot-find-lz</a></span></p><h1 class="c3 c7"><a name="h.fycpa3b90ovi"></a><span>Haskeline</span></h1><p class="c3"><span class="c10"><a class="c12" href="https://www.google.com/url?q=http://hackage.haskell.org/package/haskeline-0.7.1.3/docs/System-Console-Haskeline.html&amp;sa=D&amp;usg=AFQjCNEvCUwlEViaRGZ5tJJPlJIPYWHH0w">http://hackage.haskell.org/package/haskeline-0.7.1.3/docs/System-Console-Haskeline.html</a></span></p><p class="c3 c5"><span></span></p><p class="c3 c5"><span></span></p><h1 class="c3 c7"><a name="h.za3z80l0mbwq"></a><span>Laziness</span></h1><p class="c3 c5"><span></span></p><p class="c3"><span>From </span><span class="c10"><a class="c12" href="https://www.google.com/url?q=http://en.wikibooks.org/wiki/Haskell/Laziness&amp;sa=D&amp;usg=AFQjCNGLjaaFsnRfR3JdYvtKs7X_KtibWw">http://en.wikibooks.org/wiki/Haskell/Laziness</a></span><span>:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c9 c8 c13">Nonstrict semantics</span><span class="c9 c8"> refers to a given property of Haskell programs that you can rely on: nothing will be evaluated until it is needed.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8 c13">Lazy evaluation</span><span class="c9 c8"> is how you implement nonstrictness using a device called </span><span class="c9 c8 c13">thunks</span><span class="c9 c8">, which we explain in the next section.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">A </span><span class="c9 c8 c13">thunk</span><span class="c9 c8"> is an </span><span class="c9 c8 c16">unevaluated value</span><span class="c9 c8"> with a </span><span class="c9 c8 c16">recipe</span><span class="c9 c8"> that explains how to evaluate it.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c9 c8">Performing any degree of evaluation on a value is sometimes called </span><span class="c9 c8 c13">forcing</span><span class="c9 c8"> that value.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">The </span><span class="c9 c8 c16">only</span><span class="c9 c8"> place that Haskell values get evaluated is in pattern matches and inside certain primitive IO functions.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">If we have a constructor with strict components (annotated with an exclamation mark, as with </span><span class="c4">data MaybeS a = NothingS | JustS !a</span><span class="c9 c8">), these components become evaluated as soon as we evaluate the level above. I.e. we can never have </span><span class="c4">JustS *thunk*</span><span class="c9 c8"> — as soon as we get to this level, the strictness annotation on the component of </span><span class="c4">JustS</span><span class="c9 c8"> forces us to evaluate the component part.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">For example, the following gives an exception:</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8 c0">    let f (JustS _) = 1 in f $ JustS undefined</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Functions can be lazy or strict &#39;in an argument&#39;.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Given two functions of one parameter, </span><span class="c4">f</span><span class="c9 c8"> and </span><span class="c4">g</span><span class="c9 c8">, we say </span><span class="c4">f</span><span class="c9 c8"> is stricter than </span><span class="c4">g</span><span class="c9 c8"> if </span><span class="c4">f x </span><span class="c9 c8">evaluates </span><span class="c4">x</span><span class="c8 c9"> to a deeper level than </span><span class="c4">g x</span><span class="c9 c8">.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Often, we only care about WHNF, so a function that evaluates its argument to at least WHNF is called </span><span class="c9 c8 c16">strict</span><span class="c9 c8"> and one that performs no evaluation is </span><span class="c9 c8 c16">lazy</span><span class="c9 c8">.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">If a function is strict, passing it </span><span class="c4">undefined</span><span class="c9 c8"> will result in an error.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">When we say &quot;Does </span><span class="c4">f x</span><span class="c9 c8"> force </span><span class="c4">x</span><span class="c9 c8">?&quot; what we really mean is &quot;Given that we&#39;re forcing </span><span class="c4">f x</span><span class="c9 c8">, does </span><span class="c4">x</span><span class="c9 c8"> get forced as a result?&quot;.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8 c16">f</span><span class="c9 c8"> ⊥ = ⊥ ⇔ </span><span class="c9 c8 c16">f</span><span class="c9 c8"> is strict.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Normally, if you pattern match using a constructor as part of the pattern, you have to evaluate any argument passed into that function to make sure it matches the pattern.  For example:</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8 c0">let f (x,y) = 1 in f undefined   </span><span class="c0">⇒ </span><span class="c9 c8 c0"> </span><span class="c8 c6">exception</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">We can make the pattern matching lazy or irrefutable by adding a tilde.  For example</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8 c0">let f </span><span class="c8 c11 c0 c13">~</span><span class="c9 c8 c0">(x,y) = 1 in f undefined   </span><span class="c0">⇒</span><span class="c9 c8 c0">  </span><span class="c8 c6">1</span></p><p class="c3 c5"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8 c0">let f (Just x) = x in f $ Nothing  </span><span class="c0">⇒</span><span class="c9 c8 c0">  </span><span class="c8 c6">non-exhaustive pattern</span></p><p class="c3"><span class="c9 c8 c0">let f </span><span class="c8 c11 c0 c13">~</span><span class="c9 c8 c0">(J</span><span class="c9 c8 c0">ust x) = x in f $ Nothing  </span><span class="c0">⇒</span><span class="c9 c8 c0">  </span><span class="c8 c6">irrefutable pattern failed</span></p><p class="c3 c5"><span class="c8 c6"></span></p><p class="c3"><span class="c9 c8">Multiple equations won&#39;t work nicely with irrefutable patterns.</span></p><p class="c3 c5"><span class="c9 c8"></span></p><h1 class="c3 c7"><a name="h.m0fc0ez0av0w"></a><span>Call by need</span></h1><p class="c3"><span class="c8">Here is a bigger example of monad transformers.  It is based on </span><span class="c10 c8"><a class="c12" href="https://www.google.com/url?q=http://dev.stephendiehl.com/fun/005_evaluation.html&amp;sa=D&amp;usg=AFQjCNEsULKxel_K3Lavt2IDfo9ZyeT9uw">chapter 5</a></span><span class="c8"> of Stephen Diehl’s Write you a Haskell book.</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">import Control.Monad.State</span></p><p class="c3"><span class="c8">import Control.Monad.Writer</span></p><p class="c3"><span class="c8">import Control.Monad.Reader</span></p><p class="c3"><span class="c8">import Data.List</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">data Expr</span></p><p class="c3"><span class="c8">  = EVar String</span></p><p class="c3"><span class="c8">  | ELam String Expr</span></p><p class="c3"><span class="c8">  | EApp Expr Expr</span></p><p class="c3"><span class="c8">  | EBool Bool | EInt Integer</span></p><p class="c3"><span class="c8">  | EFix Expr</span></p><p class="c3"><span class="c8">  | EAdd Expr Expr | ESub Expr Expr | EMult Expr Expr</span></p><p class="c3"><span class="c8">  | EIf  Expr Expr Expr | EZero Expr</span></p><p class="c3"><span class="c8">  deriving (Show)</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">data Value</span></p><p class="c3"><span class="c8">  = VBool Bool</span></p><p class="c3"><span class="c8">  | VInt Integer</span></p><p class="c3"><span class="c8">  | VClosure String Expr Env deriving Show</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">ppValue :: Value -&gt; String</span></p><p class="c3"><span class="c8">ppValue (VBool n) = show n</span></p><p class="c3"><span class="c8">ppValue (VInt n) = show n</span></p><p class="c3"><span class="c8">ppValue (VClosure str ex env) = &quot;\\&quot; ++ str ++ &quot; --&gt; &quot; ++ pp ex</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">type Env = [(String, Thunk)]</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">ppEnv :: Env -&gt; String</span></p><p class="c3"><span class="c8">ppEnv env = &quot;[&quot; ++ intercalate &quot;, &quot; (map ppStrTh env) ++ &quot;]&quot;</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">ppStrTh :: (String, Thunk) -&gt; String</span></p><p class="c3"><span class="c8">ppStrTh (str, th) = &quot;(&quot; ++ str ++ &quot;, &quot; ++ ppThunk th ++ &quot;)&quot;</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">ppThunk :: Thunk -&gt; String</span></p><p class="c3"><span class="c8">ppThunk (ThLeft (ex, env)) = pp ex ++ &quot;, ...&quot;</span></p><p class="c3"><span class="c8">ppThunk (ThRight v) = ppValue v</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">data Thunk = ThLeft (Expr, Env) | ThRight Value</span></p><p class="c3"><span class="c8">  deriving Show</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">lookupEnv :: Env -&gt; String -&gt; Thunk</span></p><p class="c3"><span class="c8">lookupEnv env n =</span></p><p class="c3"><span class="c8">  maybe (error $ &quot;Unbound Variable &quot; ++ n) id $ lookup n env</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">isLam :: Expr -&gt; Bool</span></p><p class="c3"><span class="c8">isLam (ELam _ _) = True</span></p><p class="c3"><span class="c8">isLam _ = False</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">eval :: Expr -&gt; StateT Env (WriterT String (Reader String)) Value</span></p><p class="c3"><span class="c8">eval ex = do</span></p><p class="c3"><span class="c8">  indent &lt;- ask</span></p><p class="c3"><span class="c8">  env &lt;- get</span></p><p class="c3"><span class="c8">  when (not $ isLam ex) $</span></p><p class="c3"><span class="c8">    tell $ indent ++ pp ex ++ &quot;   &quot; ++ ppEnv env ++ &quot;\n\n&quot;</span></p><p class="c3"><span class="c8">  local (++ &quot;  &quot;) $ eval&#39; ex</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">eval&#39; :: Expr -&gt; StateT Env (WriterT String (Reader String)) Value</span></p><p class="c3"><span class="c8">eval&#39; ex = do</span></p><p class="c3"><span class="c8">  indent &lt;- ask</span></p><p class="c3"><span class="c8">  env &lt;- get</span></p><p class="c3"><span class="c8">  case ex of</span></p><p class="c3"><span class="c8">    EVar n -&gt; do</span></p><p class="c3"><span class="c8">      let th = lookupEnv env n</span></p><p class="c3"><span class="c8">      case th of</span></p><p class="c3"><span class="c8">        ThRight v -&gt; return v</span></p><p class="c3"><span class="c8">        ThLeft (ex&#39;, env&#39;) -&gt; do</span></p><p class="c3"><span class="c8">          let (v, str) = runReader (runWriterT $ evalStateT (eval ex&#39;) env&#39;) $ indent</span></p><p class="c3"><span class="c8">          tell str</span></p><p class="c3"><span class="c8">          put $ (n, ThRight v) : env</span></p><p class="c3"><span class="c8">          return v</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">    ELam x e -&gt; return $ VClosure x e env</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">    EApp a b -&gt; do</span></p><p class="c3"><span class="c8">      VClosure x e env&#39; &lt;- eval a</span></p><p class="c3"><span class="c8">      let (ans, str) = runReader (runWriterT $</span></p><p class="c3"><span class="c8">            evalStateT (eval e) $ (x, ThLeft (b, env)) : env&#39;) $ indent</span></p><p class="c3"><span class="c8">      tell str</span></p><p class="c3"><span class="c8">      return ans</span></p><p class="c3"><span class="c8">    </span></p><p class="c3"><span class="c8">    EBool b -&gt; return $ VBool b</span></p><p class="c3"><span class="c8">    EInt n  -&gt; return $ VInt n</span></p><p class="c3"><span class="c8">    EFix e  -&gt; eval $ EApp e $ EFix e</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">    EAdd  a b -&gt; binop (+) a b</span></p><p class="c3"><span class="c8">    ESub  a b -&gt; binop (-) a b</span></p><p class="c3"><span class="c8">    EMult a b -&gt; binop (*) a b</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">    EZero a -&gt; do</span></p><p class="c3"><span class="c8">      VInt n &lt;- eval a</span></p><p class="c3"><span class="c8">      return $ VBool $ n == 0</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">    EIf p t f -&gt; do</span></p><p class="c3"><span class="c8">      VBool p&#39; &lt;- eval p</span></p><p class="c3"><span class="c8">      eval $ if p&#39; then t else f</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">binop :: (Integer -&gt; Integer -&gt; Integer) -&gt;</span></p><p class="c3"><span class="c8">    Expr -&gt; Expr -&gt; StateT Env (WriterT String (Reader String)) Value</span></p><p class="c3"><span class="c8">binop op a b = do</span></p><p class="c3"><span class="c8">  VInt u &lt;- eval a</span></p><p class="c3"><span class="c8">  VInt v &lt;- eval b</span></p><p class="c3"><span class="c8">  return $ VInt $ u `op` v</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">pp :: Expr -&gt; String</span></p><p class="c3"><span class="c8">pp (EVar x) = x</span></p><p class="c3"><span class="c8">pp (EApp e1 e2) = &quot;(&quot; ++ pp e1 ++ &quot;) (&quot; ++ pp e2 ++ &quot;)&quot;</span></p><p class="c3"><span class="c8">pp (ELam x e) = &quot;\\&quot; ++ x ++ &quot; -&gt; &quot; ++ pp e</span></p><p class="c3"><span class="c8">pp (EInt n) = show n</span></p><p class="c3"><span class="c8">pp (EFix e) = &quot;EFix &quot; ++ pp e</span></p><p class="c3"><span class="c8">pp (EAdd e1 e2) = pp e1 ++ &quot; + &quot; ++ pp e2</span></p><p class="c3"><span class="c8">pp (ESub e1 e2) = pp e1 ++ &quot; - &quot; ++ pp e2</span></p><p class="c3"><span class="c8">pp (EMult e1 e2) = pp e1 ++ &quot; * &quot; ++ pp e2</span></p><p class="c3"><span class="c8">pp (EZero e) = &quot;EZero &quot; ++ pp e</span></p><p class="c3"><span class="c8">pp (EIf e1 e2 e3) = &quot;EIf &quot; ++ pp e1 ++ &quot; &quot; ++ pp e2 ++ &quot; &quot; ++ pp e3</span></p><p class="c3"><span class="c8">pp e = show e  </span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">-- Tests</span></p><p class="c3"><span class="c8">-- -----</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">-- diverge = fix (\x -&gt; x x)</span></p><p class="c3"><span class="c8">diverge :: Expr</span></p><p class="c3"><span class="c8">diverge = EFix (ELam &quot;x&quot; (EApp (EVar &quot;x&quot;) (EVar &quot;x&quot;)))</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">-- ignore = \x -&gt; 0</span></p><p class="c3"><span class="c8">ignore :: Expr</span></p><p class="c3"><span class="c8">ignore = ELam &quot;x&quot; (EInt 0)</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">-- omega = (\x -&gt; x x) (\x -&gt; x x)</span></p><p class="c3"><span class="c8">omega :: Expr</span></p><p class="c3"><span class="c8">omega = EApp (ELam &quot;x&quot; (EApp (EVar &quot;x&quot;) (EVar &quot;x&quot;)))</span></p><p class="c3"><span class="c8">             (ELam &quot;x&quot; (EApp (EVar &quot;x&quot;) (EVar &quot;x&quot;)))</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">-- t42 = (\y -&gt; 42) omega</span></p><p class="c3"><span class="c8">t42 = t $ EApp (ELam &quot;y&quot; (EInt 42)) omega</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">-- t0 = (\y -&gt; 0) diverge</span></p><p class="c3"><span class="c8">t0 = t $ EApp ignore diverge</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">--t :: Expr -&gt; (Value, String)</span></p><p class="c3"><span class="c8">--t ex = runWriter $ evalStateT (eval ex) []</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">t :: Expr -&gt; IO ()</span></p><p class="c3"><span class="c8">t ex = do</span></p><p class="c3"><span class="c8">  putStrLn &quot;&quot;</span></p><p class="c3"><span class="c8">  let (ans, str) = runReader (runWriterT $ evalStateT (eval ex) []) &quot;&quot;</span></p><p class="c3"><span class="c8">  putStr str</span></p><p class="c3"><span class="c8">  putStrLn $ &quot;ans = &quot; ++ show ans</span></p><p class="c3"><span class="c8">  putStrLn &quot;&quot;</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">sq = ELam &quot;q&quot; (EMult (EVar &quot;q&quot;) (EVar &quot;q&quot;))</span></p><p class="c3"><span class="c8">t4 = t $ EApp sq $ EInt 2</span></p><p class="c3"><span class="c8">t16 = t $ EApp sq $ EApp sq $ EInt 2</span></p><p class="c3"><span class="c8">t256 = t $ EApp sq $ EApp sq $ EApp sq $ EInt 2</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">plus1  = ELam &quot;x&quot; $ EAdd (EVar &quot;x&quot;) (EInt 1)</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">one = EInt 1</span></p><p class="c3"><span class="c8">n = EVar &quot;n&quot;</span></p><p class="c3"><span class="c8">r = EVar &quot;r&quot;</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">fact = ELam &quot;r&quot; $ ELam &quot;n&quot; $</span></p><p class="c3"><span class="c8">    EIf (EZero n)</span></p><p class="c3"><span class="c8">        one $</span></p><p class="c3"><span class="c8">        EMult n $ EApp r $ ESub n one</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">factorial n = EApp (EFix fact) (EInt n)</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">t0&#39; = t $ factorial 0</span></p><p class="c3"><span class="c8">t1&#39; = t $ factorial 1</span></p><p class="c3"><span class="c8">t2 = t $ factorial 2</span></p><p class="c3"><span class="c8">t6 = t $ factorial 3</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">t7 = t $ EApp plus1 $ EInt 6</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">id&#39; = ELam &quot;k&quot; $ EVar &quot;k&quot;</span></p><p class="c3"><span class="c8">t1 = t $ EApp id&#39; one</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">t5 = t $ EApp id&#39; $ EAdd (EInt 2) (EInt 3)</span></p><p class="c3 c5"><span class="c8"></span></p><p class="c3"><span class="c8">dot = ELam &quot;f&quot; $ ELam &quot;g&quot; $ ELam &quot;x&quot; $ EApp (EVar &quot;f&quot;) $ EApp (EVar &quot;g&quot;) $ EVar &quot;x&quot;</span></p><p class="c3"><span class="c8">plus2 = EApp (EApp dot plus1) plus1</span></p><p class="c3"><span class="c8">t3 = t $ EApp plus2 one</span></p><p class="c3 c5"><span class="c8"></span></p><h1 class="c3 c7"><a name="h.6rhhxbplnvbz"></a><span>Random numbers</span></h1><p class="c3 c5"><span class="c8 c6"></span></p><p class="c3"><span>This is a few highlights from System.Random.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>class RandomGen g where</span></p><p class="c3"><span>  next :: g -&gt; (Int, g)  ……</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>instance RandomGen StdGen  ……</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>mkStdGen :: Int -&gt; StdGen</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>getStdGen :: IO StdGen</span></p><p class="c3"><span>setStdGen :: StdGen -&gt; IO ()</span></p><p class="c3"><span>getStdRandom :: (StdGen -&gt; (a, StdGen)) -&gt; IO a</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>class Random a where    -- instances are Int, Char, Double, …...</span></p><p class="c3"><span>  random :: RandomGen g =&gt; g -&gt; (a, g)</span></p><p class="c3"><span>  randomR :: RandomGen g =&gt; (a, a) -&gt; g -&gt; (a, g)</span></p><p class="c3"><span>  randomIO :: IO a    -- randomIO = getStdRandom random</span></p><p class="c3"><span>  randomRIO :: (a, a) -&gt; IO a</span></p><p class="c3"><span>  ……</span></p><h1 class="c3 c7"><a name="h.qx0hla4vpneb"></a><span>Effectful</span></h1><p class="c3"><span>In this example, t</span><span>he rather trivial g function is monad-ready.  Thus the j and w functions call g from their respective monads, by passing in their effectful functions.  (I hope that is the correct terminology!).  For example, w makes the call with this strange looking construct: a &lt;- g return.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c0">import Control.Monad.Writer</span></p><p class="c3 c5"><span class="c0"></span></p><p class="c3"><span class="c0">g :: (Num a, Monad m) =&gt; (a -&gt; m a) -&gt; m a</span></p><p class="c3"><span class="c0">g f = do</span></p><p class="c3"><span class="c0">  x &lt;- f 2</span></p><p class="c3"><span class="c0">  y &lt;- f $ 2 * x</span></p><p class="c3"><span class="c0">  return y</span></p><p class="c3 c5"><span class="c0"></span></p><p class="c3"><span class="c0">j :: Maybe Int</span></p><p class="c3"><span class="c0">j = do</span></p><p class="c3"><span class="c0">  a &lt;- g Just</span></p><p class="c3"><span class="c0">  return a</span></p><p class="c3 c5"><span class="c0"></span></p><p class="c3"><span class="c0">w :: Writer String Int</span></p><p class="c3"><span class="c0">w = do</span></p><p class="c3"><span class="c0">  a &lt;- g return</span></p><p class="c3"><span class="c0">  tell &quot;hello&quot;</span></p><p class="c3"><span class="c0">  return a</span></p><h1 class="c3 c7"><a name="h.81b4lw3egaco"></a><span>Classes and instances</span></h1><p class="c3"><span>-- These simple examples demonstrate how some</span></p><p class="c3"><span>-- classes expect instances of kind, * -&gt; *.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>-- D has kind, * -&gt; * -&gt; *</span></p><p class="c3"><span>-- D a has kind, * -&gt; *</span></p><p class="c3"><span>-- D a b has kind, *</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>data D a b = D a b</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>-- This class expects instances of kind, *.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>class C a where</span></p><p class="c3"><span>  f :: a -&gt; Int</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>instance C Char where</span></p><p class="c3"><span>  f _ = 3</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>instance C (Maybe a) where</span></p><p class="c3"><span>  f _ = 4 </span></p><p class="c3 c5"><span></span></p><p class="c3"><span>instance C (D a b) where</span></p><p class="c3"><span>  f _ = 5</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>-- This class expects instances of kind, * -&gt; *,</span></p><p class="c3"><span>-- because the &#39;m&#39; in &#39;ret&#39; has a parameter.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>class Mo m where</span></p><p class="c3"><span>  ret :: a -&gt; m a</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>instance Mo Maybe where</span></p><p class="c3"><span>  ret x = Just x</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>instance Mo (D a) where</span></p><p class="c3"><span>  ret = undefined</span></p><h1 class="c3 c7"><a name="h.dxp3hyp7tu7"></a><span>Decoding the MaybeT monad instance</span></h1><p class="c3"><span>In the transformers package in the </span><span class="c10"><a class="c12" href="https://www.google.com/url?q=http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Maybe.html&amp;sa=D&amp;usg=AFQjCNFQae8jbO7RB7xI2l4qnx4NUzhGPw">Control.Monad.Trans.Maybe</a></span><span> module, there is this bit of madness:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c6">instance</span><span> </span><span class="c11">(</span><span>Monad m</span><span class="c11">)</span><span> </span><span class="c11">=&gt;</span><span> Monad </span><span class="c11">(</span><span>MaybeT m</span><span class="c11">)</span><span> </span><span class="c6">where</span><span><br>    return </span><span class="c11">=</span><span> lift . return</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>It seems crazy that the same function, “return”, can appear on the left and the right of the equation.  The answer is that “return” is a class member and therefore the “return”s on the left and the right are different functions.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>Here is the definition again, but with comments.</span></p><p class="c3 c5"><span></span></p><p class="c3"><span class="c6">instance</span><span> </span><span class="c11">(</span><span>Monad m</span><span class="c11">)</span><span> </span><span class="c11">=&gt;</span><span> Monad </span><span class="c11">(</span><span>MaybeT m</span><span class="c11">)</span><span> </span><span class="c6">where</span><span><br>    return </span><span class="c11">=</span><span>         -- a -&gt; MaybeT m a</span></p><p class="c3"><span>        lift .        -- m a -&gt; MaybeT m a</span></p><p class="c3"><span>            return    -- a -&gt; m a</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>And here is everything spelt out:</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>instance Monad m =&gt; Monad (MaybeT m) where</span></p><p class="c3"><span>    return = ret_MaybeT</span></p><p class="c3 c5"><span></span></p><p class="c3"><span>ret_MaybeT :: Monad m =&gt; a -&gt; MaybeT m a</span></p><p class="c3"><span>ret_MaybeT = let</span></p><p class="c3"><span>    lif = lift :: Monad m =&gt; m a -&gt; MaybeT m a</span></p><p class="c3"><span>    ret = return :: Monad m =&gt; a -&gt; m a</span></p><p class="c3"><span>    in lif . ret</span></p><p class="c3 c5"><span></span></p><p class="c3 c5"><span></span></p><p class="c3 c5"><span></span></p><p class="c3 c5"><span></span></p><h1 class="c3 c7"><a name="h.s8gcahze2a1d"></a><span>GHC extensions</span></h1><p class="c3"><span>These are minimal examples based on the excellent </span><span class="c10"><a class="c12" href="https://www.google.com/url?q=https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html&amp;sa=D&amp;usg=AFQjCNGHRWoHzSTblLUW25Upm0cimhoHhA">24 Days of GHC Extensions</a></span><span>.</span></p><h2 class="c3 c7"><a name="h.4dllh1e8o675"></a><span>View Patterns</span></h2><p class="c3"><span>{-# LANGUAGE ViewPatterns #-}</span></p><p class="c3"><span>f :: Int -&gt; String</span></p><p class="c3"><span>f (odd -&gt; True) = &quot;odd&quot;</span></p><p class="c3"><span>f _ = &quot;even&quot;</span></p><h2 class="c3 c7"><a name="h.5sypfe6enkuv"></a><span>Pattern Synonyms</span></h2><p class="c3"><span>{-# LANGUAGE PatternSynonyms #-}</span></p><p class="c3"><span>pattern One = 1</span></p><p class="c3"><span>f :: Int -&gt; String</span></p><p class="c3"><span>f One = &quot;One&quot;</span></p><p class="c3"><span>f _ = &quot;unknown&quot;</span></p><p class="c3"><span>k = One</span></p><h2 class="c3 c7"><a name="h.mxuyhrv0lnhd"></a><span>Record Wildcards</span></h2><p class="c3"><span>{-# LANGUAGE RecordWildCards #-}</span></p><p class="c3"><span>data Pt = Pt {x :: Int, y :: Int} deriving Show</span></p><p class="c3"><span>f :: Pt -&gt; Int</span></p><p class="c3"><span>f Pt{..} = x + y</span></p><p class="c3"><span>k :: Maybe Pt</span></p><p class="c3"><span>k = do</span></p><p class="c3"><span>  x &lt;- Just 3</span></p><p class="c3"><span>  y &lt;- Just 4</span></p><p class="c3"><span>  return Pt{..}</span></p><h2 class="c3 c7"><a name="h.fx8eyfh1dyp8"></a><span>Bang Patterns</span></h2><p class="c3"><span>{-# LANGUAGE BangPatterns #-}</span></p><p class="c3"><span>import Data.List</span></p><p class="c3"><span>mean :: [Double] -&gt; Double</span></p><p class="c3"><span>mean xs = s / fromIntegral l</span></p><p class="c3"><span>  where</span></p><p class="c3"><span>    (s, l) = foldl&#39; step (0, 0) xs</span></p><p class="c3"><span>    step (!s, !l) a = (s + a, l + 1)</span></p><h2 class="c3 c7"><a name="h.u9psveybtcen"></a><span>Rebindable Syntax</span></h2><p class="c3"><span class="c0">{-# LANGUAGE RebindableSyntax #-}</span></p><p class="c3"><span class="c0">import Prelude</span></p><p class="c3"><span class="c0">a = do</span></p><p class="c3"><span class="c0">  2</span></p><p class="c3"><span class="c0">  2</span></p><p class="c3"><span class="c0">  where (&gt;&gt;) = (+)</span></p><p class="c3"><span class="c0">        return = id</span></p><p class="c3"><span class="c0">h = &quot;a&quot; + &quot;b&quot; where (+) = (++)</span></p><p class="c3"><span class="c0">k = map 3 where map = odd</span></p><p class="c3"><span class="c0">c2f = do</span></p><p class="c3"><span class="c0">  (*9)</span></p><p class="c3"><span class="c0">  (/5)</span></p><p class="c3"><span class="c0">  (+32)</span></p><p class="c3"><span class="c0">  where (&gt;&gt;) = flip (.)</span></p><p class="c3"><span class="c0">        return = id</span></p><h2 class="c3 c7"><a name="h.sa0c4kcppn6p"></a><span>Parallel List Comprehensions</span></h2><p class="c3"><span>{-# LANGUAGE ParallelListComp #-} </span></p><p class="c3"><span>a = [ x+y | x &lt;- [1,2] </span><span class="c11 c13">,</span><span> y &lt;- [1,2] ]</span></p><p class="c3"><span>b = [ x+y | x &lt;- [1,2] </span><span class="c11 c13">|</span><span> y &lt;- [1,2] ]</span></p><h2 class="c3 c7"><a name="h.swj7whkx7fsz"></a><span>Transform List Comprehensions</span></h2><p class="c3"><span>then…  group…  by…  using...</span></p><h2 class="c3 c7"><a name="h.rops4hisw0sg"></a><span>Monad Comprehensions</span></h2><p class="c3"><span>Allows list comprehension syntax for arbitrary monads.</span></p><h2 class="c3 c7"><a name="h.ewjxc0n2196h"></a><span>Type Operators</span></h2><p class="c3"><span>{-# LANGUAGE TypeOperators #-}</span></p><p class="c3"><span>type CC = Char + Char</span></p><p class="c3"><span>data a + b = Plus a b deriving Show</span></p><p class="c3"><span>f :: Int + Int -&gt; Int + Int</span></p><p class="c3"><span>f (Plus a b) = Plus b a</span></p><h2 class="c3 c7"><a name="h.ech9qvpl7q2y"></a><span>Recursive Do</span></h2><p class="c3"><span>{-# LANGUAGE RecursiveDo #-}</span></p><p class="c3"><span>j1 = do</span></p><p class="c3"><span>  rec x &lt;- Just x</span></p><p class="c3"><span>  return 3</span></p><p class="c3"><span>j2 = mdo</span></p><p class="c3"><span>  y &lt;- Just x</span></p><p class="c3"><span>  x &lt;- Just 3</span></p><p class="c3"><span>  return y</span></p><h2 class="c3 c7"><a name="h.g07d5bh1t9g3"></a><span>Nullary Type Classes</span></h2><p class="c3"><span>{-# LANGUAGE NullaryTypeClasses #-}</span></p><p class="c3"><span>class C where</span></p><p class="c3"><span>  k :: Int</span></p><p class="c3"><span>instance C where</span></p><p class="c3"><span>  k = 3</span></p><h2 class="c3 c7"><a name="h.9mh2pqw6oxko"></a><span>Implicit Parameters</span></h2><p class="c3"><span>{-# LANGUAGE ImplicitParams #-}</span></p><p class="c3"><span>f :: (?foo :: Int) =&gt; Int</span></p><p class="c3"><span>f = ?foo * ?foo</span></p><p class="c3"><span>m :: Int</span></p><p class="c3"><span>m = let ?foo = 3 in f</span></p><h2 class="c3 c7"><a name="h.2s8p3davylf7"></a><span>Type Families</span></h2><p class="c3"><span>-- This is a huge topic!  I struggled to get anything to compile.</span></p><p class="c3"><span>{-# LANGUAGE TypeFamilies #-}</span></p><p class="c3"><span>import Data.IntSet as S</span></p><p class="c3"><span>class GSetKey k where</span></p><p class="c3"><span>  data GSet k :: *</span></p><p class="c3"><span>  member :: k -&gt; GSet k -&gt; Bool</span></p><p class="c3"><span>instance GSetKey Int where</span></p><p class="c3"><span>  data GSet Int = GSet (S.IntSet)</span></p><p class="c3"><span>  member k (GSet s) = S.member k s</span></p><h2 class="c3 c7 c22"><a name="h.y51h1che3h29"></a><span>Multi-parameter type classes</span></h2><p class="c3"><span>-- Another big topic, I think.</span></p><p class="c3"><span>{-# LANGUAGE FlexibleInstances #-}</span></p><p class="c3"><span>{-# LANGUAGE MultiParamTypeClasses #-}</span></p><p class="c3"><span>class Collection c a where</span></p><p class="c3"><span>  f :: c a -&gt; a</span></p><p class="c3"><span>data L a = L [a]</span></p><p class="c3"><span>data L2 a = L2 [[a]]</span></p><p class="c3"><span>instance Collection L a where</span></p><p class="c3"><span>  f (L [v]) = v</span></p><p class="c3"><span>instance Collection L2 a where</span></p><p class="c3"><span>  f (L2 [[v]]) = v</span></p><p class="c3"><span>instance Collection [] Int where</span></p><p class="c3"><span>  f [v] = 42  -- silly</span></p><p class="c3"><span>instance Collection Maybe a where</span></p><p class="c3"><span>  f (Just v) = v</span></p><h2 class="c3 c7"><a name="h.is5x4vtaa0oj"></a><span>Functional Dependencies</span></h2><p class="c3"><span>-- Functional Dependencies allow us to add the text shown in red.</span></p><p class="c3"><span>-- Apparently, it helps with type inferencing.</span></p><p class="c3"><span>-- Unfortunately, it broke nearly all the examples in the section above.</span></p><p class="c3"><span>{-# LANGUAGE MultiParamTypeClasses #-}</span></p><p class="c3"><span>{-# LANGUAGE FunctionalDependencies #-}</span></p><p class="c3"><span>class Collection c a</span><span class="c11"> | c -&gt; a</span><span> where</span></p><p class="c3"><span>  f :: c a -&gt; a</span></p><p class="c3"><span>data L a = L [a]</span></p><p class="c3"><span>instance Collection L Int where</span></p><p class="c3"><span>  f (L [v]) = v</span></p><h2 class="c3 c7"><a name="h.1t1lnhlax76s"></a><span>Derive Functor<br>Derive Foldable<br>Derive Traversable<br>Derive Data Typeable</span></h2><p class="c3"><span>{-# LANGUAGE DeriveFunctor #-}</span></p><p class="c3"><span>{-# LANGUAGE DeriveFoldable #-}</span></p><p class="c3"><span>{-# LANGUAGE DeriveTraversable #-}</span></p><p class="c3"><span>{-# LANGUAGE DeriveDataTypeable #-}</span></p><p class="c3"><span>import Data.Traversable</span></p><p class="c3"><span>import Data.Foldable</span></p><p class="c3"><span>import Data.Data</span></p><p class="c3"><span>import Data.Typeable</span></p><p class="c3"><span>data List a = Nil | Cons a (List a)</span></p><p class="c3"><span>  deriving (Eq, Show, Functor, Foldable, Traversable)</span></p><p class="c3"><span>-- traverse is a generalisation of mapM to more than just lists</span></p><p class="c3"><span>-- and to applicatives rather than monads.</span></p><p class="c3"><span>-- mapM :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</span></p><p class="c3"><span>-- traverse :: (Traversable t, Applicative f) =&gt;</span></p><p class="c3"><span>--                                   (a -&gt; f b) -&gt; t a -&gt; f (t b)</span></p><p class="c3"><span>-- There is also a mapM in Data.Traversable.</span></p><p class="c3"><span>-- Data.Traversable.mapM</span></p><p class="c3"><span>--    :: (Traversable t, Monad m) =&gt;</span></p><p class="c3"><span>--                 (a -&gt; m b) -&gt; t a -&gt; m (t b)</span></p><h2 class="c3 c7"><a name="h.3isjlo4wfinu"></a><span>Generalized Newtype Deriving</span></h2><p class="c3"><span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></p><p class="c3"><span>import Control.Applicative</span></p><p class="c3"><span>newtype M a = M (Maybe a) deriving</span></p><p class="c3"><span>    (Show, Functor, Applicative, Monad)</span></p><h2 class="c3 c7"><a name="h.13uphtf0v3k"></a><span>Derive Generic</span></h2><p class="c3"><span>I am going to come back to this one later.</span></p><h2 class="c3 c7"><a name="h.i48gci7lqk1"></a><span>Flexible Contexts</span></h2><p class="c3"><span>…………..</span></p><p class="c3"><span>allows us to write class constraints such as (Stream s u Char) =&gt;, where one of the type variables is defined instead of polymorphic.</span></p><h2 class="c3 c7"><a name="h.gg9wnbxh2hdr"></a><span>Overloaded Strings</span></h2><p class="c3"><span>{-# LANGUAGE OverloadedStrings #-}</span></p><p class="c3"><span>import qualified Data.Text as T</span></p><p class="c3"><span>k :: T.Text</span></p><p class="c3"><span>k = &quot;hi&quot;</span></p><h2 class="c3 c7"><a name="h.ow1t2hh7siru"></a><span>Flexible Instances</span></h2><p class="c3"><span>{-# LANGUAGE FlexibleInstances #-}</span></p><p class="c3"><span>-- I can&#39;t find the official documentation for</span></p><p class="c3"><span>-- this extension.</span></p><p class="c3"><span>-- However, I found this SO quote </span><span class="c10"><a class="c12" href="https://www.google.com/url?q=http://stackoverflow.com/questions/20145943/flexible-instances-needed&amp;sa=D&amp;usg=AFQjCNGo0HPyu0qQt7O5scGYfdTg3e0gKw">here</a></span><span>:</span></p><p class="c3"><span>--     FlexibleInstances is one of the most harmless</span></p><p class="c3"><span>--     language extensions that exist. Just enable it.</span></p><p class="c3"><span>class C a where</span></p><p class="c3"><span>  f :: a -&gt; Int</span></p><p class="c3"><span>instance C (Maybe Char) where</span></p><p class="c3"><span>  f _ = 4</span></p><p class="c3 c5"><span></span></p><p class="c3 c5"><span></span></p><p class="c3 c5"><span></span></p><p class="c3 c5"><span></span></p></div><div id="footer"><span>Published by <a target="_blank" title="Learn more about Google Drive" href="//docs.google.com/">Google Drive</a></span><span class="dash">&ndash;</span><a href="//docs.google.com/abuse?id=1DvbcQTibeUEOVmoLO14vvRa27kf6y29sObUmQpyFn9g">Report Abuse</a><span class="dash">&ndash;</span><span>Updated automatically every 5 minutes</span></div><script type="text/javascript">(function(){if(window.jstiming){window.jstiming.a={};window.jstiming.b=1;var e=function(b,a,d){var c=b.t[a],g=b.t.start;if(c&&(g||d))return c=b.t[a][0],void 0!=d?g=d:g=g[0],Math.round(c-g)},n=function(b,a,d){var c="";window.jstiming.srt&&(c+="&srt="+window.jstiming.srt,delete window.jstiming.srt);window.jstiming.pt&&(c+="&tbsrt="+window.jstiming.pt,delete window.jstiming.pt);try{window.external&&window.external.tran?c+="&tran="+window.external.tran:window.gtbExternal&&window.gtbExternal.tran?c+="&tran="+window.gtbExternal.tran():
window.chrome&&window.chrome.csi&&(c+="&tran="+window.chrome.csi().tran)}catch(g){}var f=window.chrome;if(f&&(f=f.loadTimes)){f().wasFetchedViaSpdy&&(c+="&p=s");if(f().wasNpnNegotiated){var c=c+"&npn=1",k=f().npnNegotiatedProtocol;k&&(c+="&npnv="+(encodeURIComponent||escape)(k))}f().wasAlternateProtocolAvailable&&(c+="&apa=1")}var l=b.t,t=l.start,f=[],k=[],h;for(h in l)if("start"!=h&&0!=h.indexOf("_")){var m=l[h][1];m?l[m]&&k.push(h+"."+e(b,h,l[m][0])):t&&f.push(h+"."+e(b,h))}delete l.start;if(a)for(var p in a)c+=
"&"+p+"="+a[p];(a=d)||(a="https:"==document.location.protocol?"https://csi.gstatic.com/csi":"http://csi.gstatic.com/csi");return[a,"?v=3","&s="+(window.jstiming.sn||"_s")+"&action=",b.name,k.length?"&it="+k.join(","):"",c,"&rt=",f.join(",")].join("")};window.jstiming.getReportUri=n;var q=function(b,a,d){b=n(b,a,d);if(!b)return"";a=new Image;var c=window.jstiming.b++;window.jstiming.a[c]=a;a.onload=a.onerror=function(){window.jstiming&&delete window.jstiming.a[c]};a.src=b;a=null;return b};window.jstiming.report=
function(b,a,d){if("prerender"==document.webkitVisibilityState){var c=!1,g=function(){if(!c){a?a.prerender="1":a={prerender:"1"};var f;"prerender"==document.webkitVisibilityState?f=!1:(q(b,a,d),f=!0);f&&(c=!0,document.removeEventListener("webkitvisibilitychange",g,!1))}};document.addEventListener("webkitvisibilitychange",g,!1);return""}return q(b,a,d)};window.jstiming.reportDone=function(b){if(window.jstiming.b<=(b||1))return!1;for(var a in window.jstiming.a)return!1;return!0};var r=function(b,a,
d,c){return 0<d?(c?b.tick(a,c,d):b.tick(a,"",d),!0):!1};window.jstiming.getNavTiming=function(b){if(window.performance&&window.performance.timing){var a=window.performance.timing;r(b,"_dns",a.domainLookupStart)&&r(b,"dns_",a.domainLookupEnd,"_dns");r(b,"_con",a.connectStart)&&r(b,"con_",a.connectEnd,"_con");r(b,"_req",a.requestStart)&&r(b,"req_",a.responseStart,"_req");r(b,"_rcv",a.responseStart)&&r(b,"rcv_",a.responseEnd,"_rcv");if(r(b,"_ns",a.navigationStart)){r(b,"ntsrt_",a.responseStart,"_ns");
r(b,"nsfs_",a.fetchStart,"_ns");var d=!1;try{d=window.external&&window.external.startE}catch(c){}!d&&window.chrome&&window.chrome.csi&&(d=Math.floor(window.chrome.csi().startE));d&&(r(b,"_se",d),r(b,"sens_",a.navigationStart,"_se"));r(b,"ntplt0_",a.loadEventStart,"_ns");r(b,"ntplt1_",a.loadEventEnd,"_ns")}}}};})()
</script>
<script type="text/javascript">KX_timer.tick('tl'); if (document.location.protocol == 'https:') {window.jstiming.report(KX_timer, undefined , 'https://gg.google.com/csi');} else {window.jstiming.report(KX_timer);}</script><script type="text/javascript">(function() { var k=this;
function l(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==
b&&"undefined"==typeof a.call)return"object";return b}function aa(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}function m(a,b){function c(){}c.prototype=b.prototype;a.m=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.u=function(a,c,f){for(var g=Array(arguments.length-2),h=2;h<arguments.length;h++)g[h-2]=arguments[h];return b.prototype[c].apply(a,g)}};function r(){this.b=this.b;this.a=this.a}r.prototype.b=!1;r.prototype.l=function(){this.b||(this.b=!0,this.g())};r.prototype.g=function(){if(this.a)for(;this.a.length;)this.a.shift()()};function ba(a){a&&"function"==typeof a.l&&a.l()};var t=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},ca=/&/g,da=/</g,ea=/>/g,fa=/"/g,ga=/'/g,ha=/\x00/g,ia=/[\x00&<>"']/;function u(a,b){return a<b?-1:a>b?1:0};var v=Array.prototype,ja=v.indexOf?function(a,b,c){return v.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if("string"==typeof a)return"string"==typeof b&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};function ka(a,b,c){for(var d in a)b.call(c,a[d],d,a)};function w(){this.a=x}var x={};function z(){this.a="";this.b=A}var A={};function B(a){var b=new z;b.a=a;return b}B("<!DOCTYPE html>");B("");var C;a:{var D=k.navigator;if(D){var E=D.userAgent;if(E){C=E;break a}}C=""}function F(a){return-1!=C.indexOf(a)};var la=F("Opera")||F("OPR"),G=F("Trident")||F("MSIE"),ma=F("Edge"),H=F("Gecko")&&!(-1!=C.toLowerCase().indexOf("webkit")&&!F("Edge"))&&!(F("Trident")||F("MSIE"))&&!F("Edge"),I=-1!=C.toLowerCase().indexOf("webkit")&&!F("Edge"),na=F("Macintosh");function oa(){var a=C;if(H)return/rv\:([^\);]+)(\)|;)/.exec(a);if(ma)return/Edge\/([\d\.]+)/.exec(a);if(G)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(I)return/WebKit\/(\S+)/.exec(a)}function pa(){var a=k.document;return a?a.documentMode:void 0}
var qa=function(){if(la&&k.opera){var a;var b=k.opera.version;try{a=b()}catch(c){a=b}return a}a="";(b=oa())&&(a=b?b[1]:"");return G&&(b=pa(),b>parseFloat(a))?String(b):a}(),ra={};
function J(a){var b;if(!(b=ra[a])){b=0;for(var c=t(String(qa)).split("."),d=t(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",h=d[f]||"",p=RegExp("(\\d*)(\\D*)","g"),q=RegExp("(\\d*)(\\D*)","g");do{var n=p.exec(g)||["","",""],y=q.exec(h)||["","",""];if(0==n[0].length&&0==y[0].length)break;b=u(0==n[1].length?0:parseInt(n[1],10),0==y[1].length?0:parseInt(y[1],10))||u(0==n[2].length,0==y[2].length)||u(n[2],y[2])}while(0==b)}b=ra[a]=0<=b}return b}
var sa=k.document,K=sa&&G?pa()||("CSS1Compat"==sa.compatMode?parseInt(qa,10):5):void 0;!H&&!G||G&&9<=K||H&&J("1.9.1");G&&J("9");function L(a){L[" "](a);return a}L[" "]=function(){};var ta=!G||9<=K,ua=!G||9<=K,va=G&&!J("9");!I||J("528");H&&J("1.9b")||G&&J("8")||la&&J("9.5")||I&&J("528");H&&!J("8")||G&&J("9");function M(a,b){this.type=a;this.a=this.target=b;this.f=!1}M.prototype.c=function(){this.f=!0};function N(a,b){M.call(this,a?a.type:"");this.a=this.target=null;this.g=!1;this.b=null;if(a){this.type=a.type;this.target=a.target||a.srcElement;this.a=b;var c=a.relatedTarget;if(c&&H)try{L(c.nodeName)}catch(d){}this.g=a.ctrlKey;this.b=a;a.defaultPrevented&&this.c()}}m(N,M);var wa=[1,4,2];N.prototype.c=function(){N.m.c.call(this);var a=this.b;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,va)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var xa="closure_listenable_"+(1E6*Math.random()|0),ya=0;function za(a,b,c,d,e){this.listener=a;this.a=null;this.src=b;this.type=c;this.j=!!d;this.b=e;this.o=++ya;this.h=this.i=!1}function Aa(a){a.h=!0;a.listener=null;a.a=null;a.src=null;a.b=null};function Ba(a){this.src=a;this.a={};this.b=0};var O="closure_lm_"+(1E6*Math.random()|0),P={},Ca=0;
function Da(a,b,c,d,e){if("array"==l(b)){for(var f=0;f<b.length;f++)Da(a,b[f],c,d,e);return null}c=Ea(c);if(a&&a[xa])a=Fa(a,b,c,d,e);else{f=c;if(!b)throw Error("Invalid event type");c=!!d;var g=Q(a);g||(a[O]=g=new Ba(a));var h=g,p=b.toString(),g=h.a[p];g||(g=h.a[p]=[],h.b++);var q;b:{for(q=0;q<g.length;++q){var n=g[q];if(!n.h&&n.listener==f&&n.j==!!d&&n.b==e)break b}q=-1}-1<q?(d=g[q],d.i=!1):(d=new za(f,h.src,p,!!d,e),d.i=!1,g.push(d));if(!d.a){e=Ga();d.a=e;e.src=a;e.listener=d;if(a.addEventListener)a.addEventListener(b.toString(),
e,c);else if(a.attachEvent)a.attachEvent(Ha(b.toString()),e);else throw Error("addEventListener and attachEvent are unavailable.");Ca++}a=d}return a}function Ga(){var a=Ia,b=ua?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}
function Ja(a){if("number"!=typeof a&&a&&!a.h){var b=a.src;if(b&&b[xa])b.v(a);else{var c=a.type,d=a.a;b.removeEventListener?b.removeEventListener(c,d,a.j):b.detachEvent&&b.detachEvent(Ha(c),d);Ca--;if(c=Q(b)){var d=a.type,e;if(e=d in c.a){e=c.a[d];var f=ja(e,a),g;(g=0<=f)&&v.splice.call(e,f,1);e=g}e&&(Aa(a),0==c.a[d].length&&(delete c.a[d],c.b--));0==c.b&&(c.src=null,b[O]=null)}else Aa(a)}}}function Ha(a){return a in P?P[a]:P[a]="on"+a}
function Ka(a,b,c,d){var e=!0;if(a=Q(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.j==c&&!f.h&&(f=La(f,d),e=e&&!1!==f)}return e}function La(a,b){var c=a.listener,d=a.b||a.src;a.i&&Ja(a);return c.call(d,b)}
function Ia(a,b){if(a.h)return!0;if(!ua){var c;if(!(c=b))a:{c=["window","event"];for(var d=k,e;e=c.shift();)if(null!=d[e])d=d[e];else{c=null;break a}c=d}e=c;c=new N(e,this);d=!0;if(!(0>e.keyCode||void 0!=e.returnValue)){a:{var f=!1;if(0==e.keyCode)try{e.keyCode=-1;break a}catch(g){f=!0}if(f||void 0==e.returnValue)e.returnValue=!0}e=[];for(f=c.a;f;f=f.parentNode)e.push(f);for(var f=a.type,h=e.length-1;0<=h;h--){c.a=e[h];var p=Ka(e[h],f,!0,c),d=d&&p}for(h=0;h<e.length;h++)c.a=e[h],p=Ka(e[h],f,!1,c),
d=d&&p}return d}return La(a,new N(b,this))}function Q(a){a=a[O];return a instanceof Ba?a:null}var R="__closure_events_fn_"+(1E9*Math.random()>>>0);function Ea(a){if("function"==l(a))return a;a[R]||(a[R]=function(b){return a.handleEvent(b)});return a[R]};function S(a){r.call(this);this.f=a;this.c={}}m(S,r);var Ma=[];function Fa(a,b,c,d,e){"array"!=l(c)&&(c&&(Ma[0]=c.toString()),c=Ma);for(var f=0;f<c.length;f++){var g=Da(b,c[f],d||a.handleEvent,e||!1,a.f||a);if(!g)break;a.c[g.o]=g}return a}function Na(a){ka(a.c,function(a,c){this.c.hasOwnProperty(c)&&Ja(a)},a);a.c={}}S.prototype.g=function(){S.m.g.call(this);Na(this)};S.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented");};var Oa=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/;function T(a){if(U){U=!1;var b=k.location;if(b){var c=b.href;if(c&&(c=V(T(c)[3]||null))&&c!=b.hostname)throw U=!0,Error();}}return a.match(Oa)}var U=I;function V(a){return a?decodeURI(a):a}var Pa=/#|$/;
function Qa(a,b){var c=a.search(Pa),d;a:{d=0;for(var e=b.length;0<=(d=a.indexOf(b,d))&&d<c;){var f=a.charCodeAt(d-1);if(38==f||63==f)if(f=a.charCodeAt(d+e),!f||61==f||38==f||35==f)break a;d+=e+1}d=-1}if(0>d)return null;e=a.indexOf("&",d);if(0>e||e>c)e=c;d+=b.length+1;return decodeURIComponent(a.substr(d,e-d).replace(/\+/g," "))};function W(a){r.call(this);this.c=a||document.body;this.f=new S(this);a=aa(ba,this.f);this.b?a.call(void 0):(this.a||(this.a=[]),this.a.push(a));Fa(this.f,this.c,"click",this.s,void 0)}m(W,r);
W.prototype.s=function(a){if((ta?0==a.b.button:"click"==a.type||a.b.button&wa[0])&&!(I&&na&&a.g)&&!a.f)for(var b=a.target;b&&b!=this.c;){if(b.tagName&&"a"==b.tagName.toLowerCase()){var c=b.getAttribute("href")||b.getAttributeNS("http://www.w3.org/1999/xlink","href"),d,e=d=c;try{"www.google.com"==V(T(d)[3]||null)&&"/url"==V(T(d)[5]||null)&&(e=Qa(d,"q")||Qa(d,"url"))}catch(f){}d=e?e:"";if(c!=d){e=d;c={target:"_blank",noreferrer:!0};b=window;d=void 0;e instanceof w?d=e instanceof w&&e.constructor===
w&&e.a===x?"":"type_error:SafeUrl":d="undefined"!=typeof e.href?e.href:String(e);var e=c.target||e.target,g=[],h=void 0;for(h in c)switch(h){case "width":case "height":case "top":case "left":g.push(h+"="+c[h]);break;case "target":case "noreferrer":break;default:g.push(h+"="+(c[h]?1:0))}h=g.join(",");g=void 0;if((F("iPhone")&&!F("iPod")&&!F("iPad")||F("iPad")||F("iPod"))&&b.navigator&&b.navigator.standalone&&e&&"_self"!=e)g=b.document.createElement("A"),g.setAttribute("href",d),g.setAttribute("target",
e),c.noreferrer&&g.setAttribute("rel","noreferrer"),c=document.createEvent("MouseEvent"),c.initMouseEvent("click",!0,!0,b,1),g.dispatchEvent(c);else if(c.noreferrer){if(g=b.open("",e,h))G&&-1!=d.indexOf(";")&&(d="'"+d.replace(/'/g,"%27")+"'"),g.opener=null,b=d,ia.test(b)&&(-1!=b.indexOf("&")&&(b=b.replace(ca,"&amp;")),-1!=b.indexOf("<")&&(b=b.replace(da,"&lt;")),-1!=b.indexOf(">")&&(b=b.replace(ea,"&gt;")),-1!=b.indexOf('"')&&(b=b.replace(fa,"&quot;")),-1!=b.indexOf("'")&&(b=b.replace(ga,"&#39;")),
-1!=b.indexOf("\x00")&&(b=b.replace(ha,"&#0;"))),b=B('<META HTTP-EQUIV="refresh" content="0; url='+b+'">'),g.document.write(b instanceof z&&b.constructor===z&&b.b===A?b.a:"type_error:SafeHtml"),g.document.close()}else b.open(d,e,h);a.c();break}}b=b.parentNode}};function Ra(a){new W(a)}var X=["DOCS_installLinkReferrerSanitizer"],Y=k;X[0]in Y||!Y.execScript||Y.execScript("var "+X[0]);for(var Z;X.length&&(Z=X.shift());)X.length||void 0===Ra?Y[Z]?Y=Y[Z]:Y=Y[Z]={}:Y[Z]=Ra; })()
</script>
<script type="text/javascript">DOCS_installLinkReferrerSanitizer();</script></body></html>
